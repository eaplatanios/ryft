#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJRT_Api {
    _unused: [u8; 0],
}

unsafe extern "C" {
    pub fn GetPjrtApi() -> *const PJRT_Api;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XlaCustomCallStatus {
    _unused: [u8; 0],
}

unsafe extern "C" {
    pub fn XlaCustomCallStatusSetSuccess(status: *mut XlaCustomCallStatus);
}

unsafe extern "C" {
    pub fn XlaCustomCallStatusSetFailure(
        status: *mut XlaCustomCallStatus,
        message: *const ::std::os::raw::c_char,
        message_len: usize,
    );
}

/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_InternalApi {
    _unused: [u8; 0],
}
pub const XLA_FFI_Extension_Type_XLA_FFI_Extension_Metadata: XLA_FFI_Extension_Type = 1;
pub type XLA_FFI_Extension_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Extension_Base {
    pub struct_size: usize,
    pub type_: XLA_FFI_Extension_Type,
    pub next: *mut XLA_FFI_Extension_Base,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Extension_Base"][::std::mem::size_of::<XLA_FFI_Extension_Base>() - 24usize];
    ["Alignment of XLA_FFI_Extension_Base"][::std::mem::align_of::<XLA_FFI_Extension_Base>() - 8usize];
    ["Offset of field: XLA_FFI_Extension_Base::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Extension_Base, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Extension_Base::type_"][::std::mem::offset_of!(XLA_FFI_Extension_Base, type_) - 8usize];
    ["Offset of field: XLA_FFI_Extension_Base::next"][::std::mem::offset_of!(XLA_FFI_Extension_Base, next) - 16usize];
};
pub const XLA_FFI_Extension_Base_STRUCT_SIZE: _bindgen_ty_177 = 24;
pub type _bindgen_ty_177 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Api_Version {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub major_version: ::std::os::raw::c_int,
    pub minor_version: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Api_Version"][::std::mem::size_of::<XLA_FFI_Api_Version>() - 24usize];
    ["Alignment of XLA_FFI_Api_Version"][::std::mem::align_of::<XLA_FFI_Api_Version>() - 8usize];
    ["Offset of field: XLA_FFI_Api_Version::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Api_Version, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Api_Version::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Api_Version, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Api_Version::major_version"]
        [::std::mem::offset_of!(XLA_FFI_Api_Version, major_version) - 16usize];
    ["Offset of field: XLA_FFI_Api_Version::minor_version"]
        [::std::mem::offset_of!(XLA_FFI_Api_Version, minor_version) - 20usize];
};
pub const XLA_FFI_Api_Version_STRUCT_SIZE: _bindgen_ty_178 = 24;
pub type _bindgen_ty_178 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Error {
    _unused: [u8; 0],
}
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_OK: XLA_FFI_Error_Code = 0;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_CANCELLED: XLA_FFI_Error_Code = 1;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_UNKNOWN: XLA_FFI_Error_Code = 2;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_INVALID_ARGUMENT: XLA_FFI_Error_Code = 3;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_DEADLINE_EXCEEDED: XLA_FFI_Error_Code = 4;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_NOT_FOUND: XLA_FFI_Error_Code = 5;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_ALREADY_EXISTS: XLA_FFI_Error_Code = 6;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_PERMISSION_DENIED: XLA_FFI_Error_Code = 7;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_RESOURCE_EXHAUSTED: XLA_FFI_Error_Code = 8;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_FAILED_PRECONDITION: XLA_FFI_Error_Code = 9;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_ABORTED: XLA_FFI_Error_Code = 10;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_OUT_OF_RANGE: XLA_FFI_Error_Code = 11;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_UNIMPLEMENTED: XLA_FFI_Error_Code = 12;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_INTERNAL: XLA_FFI_Error_Code = 13;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_UNAVAILABLE: XLA_FFI_Error_Code = 14;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_DATA_LOSS: XLA_FFI_Error_Code = 15;
pub const XLA_FFI_Error_Code_XLA_FFI_Error_Code_UNAUTHENTICATED: XLA_FFI_Error_Code = 16;
pub type XLA_FFI_Error_Code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Error_Create_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub message: *const ::std::os::raw::c_char,
    pub errc: XLA_FFI_Error_Code,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Error_Create_Args"][::std::mem::size_of::<XLA_FFI_Error_Create_Args>() - 32usize];
    ["Alignment of XLA_FFI_Error_Create_Args"][::std::mem::align_of::<XLA_FFI_Error_Create_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Error_Create_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Error_Create_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Error_Create_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Error_Create_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Error_Create_Args::message"]
        [::std::mem::offset_of!(XLA_FFI_Error_Create_Args, message) - 16usize];
    ["Offset of field: XLA_FFI_Error_Create_Args::errc"]
        [::std::mem::offset_of!(XLA_FFI_Error_Create_Args, errc) - 24usize];
};
pub const XLA_FFI_Error_Create_Args_STRUCT_SIZE: _bindgen_ty_179 = 28;
pub type _bindgen_ty_179 = ::std::os::raw::c_uint;
pub type XLA_FFI_Error_Create =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Error_Create_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Error_GetMessage_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub error: *mut XLA_FFI_Error,
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Error_GetMessage_Args"][::std::mem::size_of::<XLA_FFI_Error_GetMessage_Args>() - 32usize];
    ["Alignment of XLA_FFI_Error_GetMessage_Args"][::std::mem::align_of::<XLA_FFI_Error_GetMessage_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Error_GetMessage_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Error_GetMessage_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Error_GetMessage_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Error_GetMessage_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Error_GetMessage_Args::error"]
        [::std::mem::offset_of!(XLA_FFI_Error_GetMessage_Args, error) - 16usize];
    ["Offset of field: XLA_FFI_Error_GetMessage_Args::message"]
        [::std::mem::offset_of!(XLA_FFI_Error_GetMessage_Args, message) - 24usize];
};
pub const XLA_FFI_Error_GetMessage_Args_STRUCT_SIZE: _bindgen_ty_180 = 32;
pub type _bindgen_ty_180 = ::std::os::raw::c_uint;
pub type XLA_FFI_Error_GetMessage =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Error_GetMessage_Args)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Error_Destroy_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub error: *mut XLA_FFI_Error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Error_Destroy_Args"][::std::mem::size_of::<XLA_FFI_Error_Destroy_Args>() - 24usize];
    ["Alignment of XLA_FFI_Error_Destroy_Args"][::std::mem::align_of::<XLA_FFI_Error_Destroy_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Error_Destroy_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Error_Destroy_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Error_Destroy_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Error_Destroy_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Error_Destroy_Args::error"]
        [::std::mem::offset_of!(XLA_FFI_Error_Destroy_Args, error) - 16usize];
};
pub const XLA_FFI_Error_Destroy_Args_STRUCT_SIZE: _bindgen_ty_181 = 24;
pub type _bindgen_ty_181 = ::std::os::raw::c_uint;
pub type XLA_FFI_Error_Destroy = ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Error_Destroy_Args)>;
pub const XLA_FFI_DataType_XLA_FFI_DataType_INVALID: XLA_FFI_DataType = 0;
pub const XLA_FFI_DataType_XLA_FFI_DataType_PRED: XLA_FFI_DataType = 1;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S1: XLA_FFI_DataType = 30;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S2: XLA_FFI_DataType = 26;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S4: XLA_FFI_DataType = 21;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S8: XLA_FFI_DataType = 2;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S16: XLA_FFI_DataType = 3;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S32: XLA_FFI_DataType = 4;
pub const XLA_FFI_DataType_XLA_FFI_DataType_S64: XLA_FFI_DataType = 5;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U1: XLA_FFI_DataType = 31;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U2: XLA_FFI_DataType = 27;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U4: XLA_FFI_DataType = 22;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U8: XLA_FFI_DataType = 6;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U16: XLA_FFI_DataType = 7;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U32: XLA_FFI_DataType = 8;
pub const XLA_FFI_DataType_XLA_FFI_DataType_U64: XLA_FFI_DataType = 9;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F16: XLA_FFI_DataType = 10;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F32: XLA_FFI_DataType = 11;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F64: XLA_FFI_DataType = 12;
pub const XLA_FFI_DataType_XLA_FFI_DataType_BF16: XLA_FFI_DataType = 16;
pub const XLA_FFI_DataType_XLA_FFI_DataType_C64: XLA_FFI_DataType = 15;
pub const XLA_FFI_DataType_XLA_FFI_DataType_C128: XLA_FFI_DataType = 18;
pub const XLA_FFI_DataType_XLA_FFI_DataType_TOKEN: XLA_FFI_DataType = 17;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E5M2: XLA_FFI_DataType = 19;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E3M4: XLA_FFI_DataType = 29;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E4M3: XLA_FFI_DataType = 28;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E4M3FN: XLA_FFI_DataType = 20;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E4M3B11FNUZ: XLA_FFI_DataType = 23;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E5M2FNUZ: XLA_FFI_DataType = 24;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E4M3FNUZ: XLA_FFI_DataType = 25;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F4E2M1FN: XLA_FFI_DataType = 32;
pub const XLA_FFI_DataType_XLA_FFI_DataType_F8E8M0FNU: XLA_FFI_DataType = 33;
pub type XLA_FFI_DataType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Buffer {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub dtype: XLA_FFI_DataType,
    pub data: *mut ::std::os::raw::c_void,
    pub rank: i64,
    pub dims: *mut i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Buffer"][::std::mem::size_of::<XLA_FFI_Buffer>() - 48usize];
    ["Alignment of XLA_FFI_Buffer"][::std::mem::align_of::<XLA_FFI_Buffer>() - 8usize];
    ["Offset of field: XLA_FFI_Buffer::struct_size"][::std::mem::offset_of!(XLA_FFI_Buffer, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Buffer::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Buffer, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Buffer::dtype"][::std::mem::offset_of!(XLA_FFI_Buffer, dtype) - 16usize];
    ["Offset of field: XLA_FFI_Buffer::data"][::std::mem::offset_of!(XLA_FFI_Buffer, data) - 24usize];
    ["Offset of field: XLA_FFI_Buffer::rank"][::std::mem::offset_of!(XLA_FFI_Buffer, rank) - 32usize];
    ["Offset of field: XLA_FFI_Buffer::dims"][::std::mem::offset_of!(XLA_FFI_Buffer, dims) - 40usize];
};
pub const XLA_FFI_Buffer_STRUCT_SIZE: _bindgen_ty_182 = 48;
pub type _bindgen_ty_182 = ::std::os::raw::c_uint;
pub const XLA_FFI_ArgType_XLA_FFI_ArgType_BUFFER: XLA_FFI_ArgType = 1;
pub type XLA_FFI_ArgType = ::std::os::raw::c_uint;
pub const XLA_FFI_RetType_XLA_FFI_RetType_BUFFER: XLA_FFI_RetType = 1;
pub type XLA_FFI_RetType = ::std::os::raw::c_uint;
pub const XLA_FFI_AttrType_XLA_FFI_AttrType_ARRAY: XLA_FFI_AttrType = 1;
pub const XLA_FFI_AttrType_XLA_FFI_AttrType_DICTIONARY: XLA_FFI_AttrType = 2;
pub const XLA_FFI_AttrType_XLA_FFI_AttrType_SCALAR: XLA_FFI_AttrType = 3;
pub const XLA_FFI_AttrType_XLA_FFI_AttrType_STRING: XLA_FFI_AttrType = 4;
pub type XLA_FFI_AttrType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_ExecutionContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_ByteSpan {
    pub ptr: *const ::std::os::raw::c_char,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_ByteSpan"][::std::mem::size_of::<XLA_FFI_ByteSpan>() - 16usize];
    ["Alignment of XLA_FFI_ByteSpan"][::std::mem::align_of::<XLA_FFI_ByteSpan>() - 8usize];
    ["Offset of field: XLA_FFI_ByteSpan::ptr"][::std::mem::offset_of!(XLA_FFI_ByteSpan, ptr) - 0usize];
    ["Offset of field: XLA_FFI_ByteSpan::len"][::std::mem::offset_of!(XLA_FFI_ByteSpan, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Scalar {
    pub dtype: XLA_FFI_DataType,
    pub value: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Scalar"][::std::mem::size_of::<XLA_FFI_Scalar>() - 16usize];
    ["Alignment of XLA_FFI_Scalar"][::std::mem::align_of::<XLA_FFI_Scalar>() - 8usize];
    ["Offset of field: XLA_FFI_Scalar::dtype"][::std::mem::offset_of!(XLA_FFI_Scalar, dtype) - 0usize];
    ["Offset of field: XLA_FFI_Scalar::value"][::std::mem::offset_of!(XLA_FFI_Scalar, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Array {
    pub dtype: XLA_FFI_DataType,
    pub size: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Array"][::std::mem::size_of::<XLA_FFI_Array>() - 24usize];
    ["Alignment of XLA_FFI_Array"][::std::mem::align_of::<XLA_FFI_Array>() - 8usize];
    ["Offset of field: XLA_FFI_Array::dtype"][::std::mem::offset_of!(XLA_FFI_Array, dtype) - 0usize];
    ["Offset of field: XLA_FFI_Array::size"][::std::mem::offset_of!(XLA_FFI_Array, size) - 8usize];
    ["Offset of field: XLA_FFI_Array::data"][::std::mem::offset_of!(XLA_FFI_Array, data) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_TypeId {
    pub type_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_TypeId"][::std::mem::size_of::<XLA_FFI_TypeId>() - 8usize];
    ["Alignment of XLA_FFI_TypeId"][::std::mem::align_of::<XLA_FFI_TypeId>() - 8usize];
    ["Offset of field: XLA_FFI_TypeId::type_id"][::std::mem::offset_of!(XLA_FFI_TypeId, type_id) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_TypeInfo {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub deleter: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_TypeInfo"][::std::mem::size_of::<XLA_FFI_TypeInfo>() - 24usize];
    ["Alignment of XLA_FFI_TypeInfo"][::std::mem::align_of::<XLA_FFI_TypeInfo>() - 8usize];
    ["Offset of field: XLA_FFI_TypeInfo::struct_size"][::std::mem::offset_of!(XLA_FFI_TypeInfo, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_TypeInfo::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_TypeInfo, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_TypeInfo::deleter"][::std::mem::offset_of!(XLA_FFI_TypeInfo, deleter) - 16usize];
};
pub const XLA_FFI_TypeInfo_STRUCT_SIZE: _bindgen_ty_183 = 24;
pub type _bindgen_ty_183 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Future {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Future_Create_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub future: *mut XLA_FFI_Future,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Future_Create_Args"][::std::mem::size_of::<XLA_FFI_Future_Create_Args>() - 24usize];
    ["Alignment of XLA_FFI_Future_Create_Args"][::std::mem::align_of::<XLA_FFI_Future_Create_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Future_Create_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Future_Create_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Future_Create_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Future_Create_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Future_Create_Args::future"]
        [::std::mem::offset_of!(XLA_FFI_Future_Create_Args, future) - 16usize];
};
pub const XLA_FFI_Future_Create_Args_STRUCT_SIZE: _bindgen_ty_184 = 16;
pub type _bindgen_ty_184 = ::std::os::raw::c_uint;
pub type XLA_FFI_Future_Create =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Future_Create_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Future_SetAvailable_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub future: *mut XLA_FFI_Future,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Future_SetAvailable_Args"][::std::mem::size_of::<XLA_FFI_Future_SetAvailable_Args>() - 24usize];
    ["Alignment of XLA_FFI_Future_SetAvailable_Args"]
        [::std::mem::align_of::<XLA_FFI_Future_SetAvailable_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Future_SetAvailable_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetAvailable_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Future_SetAvailable_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetAvailable_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Future_SetAvailable_Args::future"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetAvailable_Args, future) - 16usize];
};
pub const XLA_FFI_Future_SetAvailable_Args_STRUCT_SIZE: _bindgen_ty_185 = 24;
pub type _bindgen_ty_185 = ::std::os::raw::c_uint;
pub type XLA_FFI_Future_SetAvailable =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Future_SetAvailable_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Future_SetError_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub future: *mut XLA_FFI_Future,
    pub error: *mut XLA_FFI_Error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Future_SetError_Args"][::std::mem::size_of::<XLA_FFI_Future_SetError_Args>() - 32usize];
    ["Alignment of XLA_FFI_Future_SetError_Args"][::std::mem::align_of::<XLA_FFI_Future_SetError_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Future_SetError_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetError_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Future_SetError_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetError_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Future_SetError_Args::future"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetError_Args, future) - 16usize];
    ["Offset of field: XLA_FFI_Future_SetError_Args::error"]
        [::std::mem::offset_of!(XLA_FFI_Future_SetError_Args, error) - 24usize];
};
pub const XLA_FFI_Future_SetError_Args_STRUCT_SIZE: _bindgen_ty_186 = 32;
pub type _bindgen_ty_186 = ::std::os::raw::c_uint;
pub type XLA_FFI_Future_SetError =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Future_SetError_Args) -> *mut XLA_FFI_Error>;
pub const XLA_FFI_ExecutionStage_XLA_FFI_ExecutionStage_INSTANTIATE: XLA_FFI_ExecutionStage = 0;
pub const XLA_FFI_ExecutionStage_XLA_FFI_ExecutionStage_PREPARE: XLA_FFI_ExecutionStage = 1;
pub const XLA_FFI_ExecutionStage_XLA_FFI_ExecutionStage_INITIALIZE: XLA_FFI_ExecutionStage = 2;
pub const XLA_FFI_ExecutionStage_XLA_FFI_ExecutionStage_EXECUTE: XLA_FFI_ExecutionStage = 3;
pub type XLA_FFI_ExecutionStage = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub size: i64,
    pub types: *mut XLA_FFI_ArgType,
    pub args: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Args"][::std::mem::size_of::<XLA_FFI_Args>() - 40usize];
    ["Alignment of XLA_FFI_Args"][::std::mem::align_of::<XLA_FFI_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Args::struct_size"][::std::mem::offset_of!(XLA_FFI_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Args::extension_start"][::std::mem::offset_of!(XLA_FFI_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Args::size"][::std::mem::offset_of!(XLA_FFI_Args, size) - 16usize];
    ["Offset of field: XLA_FFI_Args::types"][::std::mem::offset_of!(XLA_FFI_Args, types) - 24usize];
    ["Offset of field: XLA_FFI_Args::args"][::std::mem::offset_of!(XLA_FFI_Args, args) - 32usize];
};
pub const XLA_FFI_Args_STRUCT_SIZE: _bindgen_ty_187 = 40;
pub type _bindgen_ty_187 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Rets {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub size: i64,
    pub types: *mut XLA_FFI_RetType,
    pub rets: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Rets"][::std::mem::size_of::<XLA_FFI_Rets>() - 40usize];
    ["Alignment of XLA_FFI_Rets"][::std::mem::align_of::<XLA_FFI_Rets>() - 8usize];
    ["Offset of field: XLA_FFI_Rets::struct_size"][::std::mem::offset_of!(XLA_FFI_Rets, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Rets::extension_start"][::std::mem::offset_of!(XLA_FFI_Rets, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Rets::size"][::std::mem::offset_of!(XLA_FFI_Rets, size) - 16usize];
    ["Offset of field: XLA_FFI_Rets::types"][::std::mem::offset_of!(XLA_FFI_Rets, types) - 24usize];
    ["Offset of field: XLA_FFI_Rets::rets"][::std::mem::offset_of!(XLA_FFI_Rets, rets) - 32usize];
};
pub const XLA_FFI_Rets_STRUCT_SIZE: _bindgen_ty_188 = 40;
pub type _bindgen_ty_188 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Attrs {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub size: i64,
    pub types: *mut XLA_FFI_AttrType,
    pub names: *mut *mut XLA_FFI_ByteSpan,
    pub attrs: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Attrs"][::std::mem::size_of::<XLA_FFI_Attrs>() - 48usize];
    ["Alignment of XLA_FFI_Attrs"][::std::mem::align_of::<XLA_FFI_Attrs>() - 8usize];
    ["Offset of field: XLA_FFI_Attrs::struct_size"][::std::mem::offset_of!(XLA_FFI_Attrs, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Attrs::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Attrs, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Attrs::size"][::std::mem::offset_of!(XLA_FFI_Attrs, size) - 16usize];
    ["Offset of field: XLA_FFI_Attrs::types"][::std::mem::offset_of!(XLA_FFI_Attrs, types) - 24usize];
    ["Offset of field: XLA_FFI_Attrs::names"][::std::mem::offset_of!(XLA_FFI_Attrs, names) - 32usize];
    ["Offset of field: XLA_FFI_Attrs::attrs"][::std::mem::offset_of!(XLA_FFI_Attrs, attrs) - 40usize];
};
pub const XLA_FFI_Attrs_STRUCT_SIZE: _bindgen_ty_189 = 48;
pub type _bindgen_ty_189 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_CallFrame {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub api: *const XLA_FFI_Api,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub stage: XLA_FFI_ExecutionStage,
    pub args: XLA_FFI_Args,
    pub rets: XLA_FFI_Rets,
    pub attrs: XLA_FFI_Attrs,
    pub future: *mut XLA_FFI_Future,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_CallFrame"][::std::mem::size_of::<XLA_FFI_CallFrame>() - 176usize];
    ["Alignment of XLA_FFI_CallFrame"][::std::mem::align_of::<XLA_FFI_CallFrame>() - 8usize];
    ["Offset of field: XLA_FFI_CallFrame::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_CallFrame, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_CallFrame::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_CallFrame, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_CallFrame::api"][::std::mem::offset_of!(XLA_FFI_CallFrame, api) - 16usize];
    ["Offset of field: XLA_FFI_CallFrame::ctx"][::std::mem::offset_of!(XLA_FFI_CallFrame, ctx) - 24usize];
    ["Offset of field: XLA_FFI_CallFrame::stage"][::std::mem::offset_of!(XLA_FFI_CallFrame, stage) - 32usize];
    ["Offset of field: XLA_FFI_CallFrame::args"][::std::mem::offset_of!(XLA_FFI_CallFrame, args) - 40usize];
    ["Offset of field: XLA_FFI_CallFrame::rets"][::std::mem::offset_of!(XLA_FFI_CallFrame, rets) - 80usize];
    ["Offset of field: XLA_FFI_CallFrame::attrs"][::std::mem::offset_of!(XLA_FFI_CallFrame, attrs) - 120usize];
    ["Offset of field: XLA_FFI_CallFrame::future"][::std::mem::offset_of!(XLA_FFI_CallFrame, future) - 168usize];
};
pub const XLA_FFI_CallFrame_STRUCT_SIZE: _bindgen_ty_190 = 168;
pub type _bindgen_ty_190 = ::std::os::raw::c_uint;
pub type XLA_FFI_Handler =
    ::std::option::Option<unsafe extern "C" fn(call_frame: *mut XLA_FFI_CallFrame) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Handler_Bundle {
    pub instantiate: XLA_FFI_Handler,
    pub prepare: XLA_FFI_Handler,
    pub initialize: XLA_FFI_Handler,
    pub execute: XLA_FFI_Handler,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Handler_Bundle"][::std::mem::size_of::<XLA_FFI_Handler_Bundle>() - 32usize];
    ["Alignment of XLA_FFI_Handler_Bundle"][::std::mem::align_of::<XLA_FFI_Handler_Bundle>() - 8usize];
    ["Offset of field: XLA_FFI_Handler_Bundle::instantiate"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Bundle, instantiate) - 0usize];
    ["Offset of field: XLA_FFI_Handler_Bundle::prepare"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Bundle, prepare) - 8usize];
    ["Offset of field: XLA_FFI_Handler_Bundle::initialize"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Bundle, initialize) - 16usize];
    ["Offset of field: XLA_FFI_Handler_Bundle::execute"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Bundle, execute) - 24usize];
};
pub const XLA_FFI_Handler_TraitsBits_XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE: XLA_FFI_Handler_TraitsBits = 1;
pub type XLA_FFI_Handler_TraitsBits = ::std::os::raw::c_uint;
pub type XLA_FFI_Handler_Traits = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Handler_Register_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub name: XLA_FFI_ByteSpan,
    pub platform: XLA_FFI_ByteSpan,
    pub bundle: XLA_FFI_Handler_Bundle,
    pub traits: XLA_FFI_Handler_Traits,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Handler_Register_Args"][::std::mem::size_of::<XLA_FFI_Handler_Register_Args>() - 88usize];
    ["Alignment of XLA_FFI_Handler_Register_Args"][::std::mem::align_of::<XLA_FFI_Handler_Register_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Handler_Register_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Register_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Handler_Register_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Register_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Handler_Register_Args::name"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Register_Args, name) - 16usize];
    ["Offset of field: XLA_FFI_Handler_Register_Args::platform"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Register_Args, platform) - 32usize];
    ["Offset of field: XLA_FFI_Handler_Register_Args::bundle"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Register_Args, bundle) - 48usize];
    ["Offset of field: XLA_FFI_Handler_Register_Args::traits"]
        [::std::mem::offset_of!(XLA_FFI_Handler_Register_Args, traits) - 80usize];
};
pub const XLA_FFI_Handler_Register_Args_STRUCT_SIZE: _bindgen_ty_191 = 84;
pub type _bindgen_ty_191 = ::std::os::raw::c_uint;
pub type XLA_FFI_Handler_Register =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Handler_Register_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Type_Register_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub name: XLA_FFI_ByteSpan,
    pub type_id: *mut XLA_FFI_TypeId,
    pub type_info: *const XLA_FFI_TypeInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Type_Register_Args"][::std::mem::size_of::<XLA_FFI_Type_Register_Args>() - 48usize];
    ["Alignment of XLA_FFI_Type_Register_Args"][::std::mem::align_of::<XLA_FFI_Type_Register_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Type_Register_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Type_Register_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Type_Register_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Type_Register_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Type_Register_Args::name"]
        [::std::mem::offset_of!(XLA_FFI_Type_Register_Args, name) - 16usize];
    ["Offset of field: XLA_FFI_Type_Register_Args::type_id"]
        [::std::mem::offset_of!(XLA_FFI_Type_Register_Args, type_id) - 32usize];
    ["Offset of field: XLA_FFI_Type_Register_Args::type_info"]
        [::std::mem::offset_of!(XLA_FFI_Type_Register_Args, type_info) - 40usize];
};
pub const XLA_FFI_Type_Register_Args_STRUCT_SIZE: _bindgen_ty_192 = 40;
pub type _bindgen_ty_192 = ::std::os::raw::c_uint;
pub type XLA_FFI_Type_Register =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Type_Register_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_ExecutionContext_Get_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub type_id: *mut XLA_FFI_TypeId,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_ExecutionContext_Get_Args"][::std::mem::size_of::<XLA_FFI_ExecutionContext_Get_Args>() - 40usize];
    ["Alignment of XLA_FFI_ExecutionContext_Get_Args"]
        [::std::mem::align_of::<XLA_FFI_ExecutionContext_Get_Args>() - 8usize];
    ["Offset of field: XLA_FFI_ExecutionContext_Get_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_ExecutionContext_Get_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_ExecutionContext_Get_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_ExecutionContext_Get_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_ExecutionContext_Get_Args::ctx"]
        [::std::mem::offset_of!(XLA_FFI_ExecutionContext_Get_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_ExecutionContext_Get_Args::type_id"]
        [::std::mem::offset_of!(XLA_FFI_ExecutionContext_Get_Args, type_id) - 24usize];
    ["Offset of field: XLA_FFI_ExecutionContext_Get_Args::data"]
        [::std::mem::offset_of!(XLA_FFI_ExecutionContext_Get_Args, data) - 32usize];
};
pub const XLA_FFI_ExecutionContext_Get_Args_STRUCT_SIZE: _bindgen_ty_193 = 40;
pub type _bindgen_ty_193 = ::std::os::raw::c_uint;
pub type XLA_FFI_ExecutionContext_Get =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_ExecutionContext_Get_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_State_Set_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub type_id: *mut XLA_FFI_TypeId,
    pub state: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_State_Set_Args"][::std::mem::size_of::<XLA_FFI_State_Set_Args>() - 40usize];
    ["Alignment of XLA_FFI_State_Set_Args"][::std::mem::align_of::<XLA_FFI_State_Set_Args>() - 8usize];
    ["Offset of field: XLA_FFI_State_Set_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_State_Set_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_State_Set_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_State_Set_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_State_Set_Args::ctx"][::std::mem::offset_of!(XLA_FFI_State_Set_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_State_Set_Args::type_id"]
        [::std::mem::offset_of!(XLA_FFI_State_Set_Args, type_id) - 24usize];
    ["Offset of field: XLA_FFI_State_Set_Args::state"][::std::mem::offset_of!(XLA_FFI_State_Set_Args, state) - 32usize];
};
pub const XLA_FFI_State_Set_Args_STRUCT_SIZE: _bindgen_ty_194 = 40;
pub type _bindgen_ty_194 = ::std::os::raw::c_uint;
pub type XLA_FFI_State_Set =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_State_Set_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_State_Get_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub type_id: *mut XLA_FFI_TypeId,
    pub state: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_State_Get_Args"][::std::mem::size_of::<XLA_FFI_State_Get_Args>() - 40usize];
    ["Alignment of XLA_FFI_State_Get_Args"][::std::mem::align_of::<XLA_FFI_State_Get_Args>() - 8usize];
    ["Offset of field: XLA_FFI_State_Get_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_State_Get_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_State_Get_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_State_Get_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_State_Get_Args::ctx"][::std::mem::offset_of!(XLA_FFI_State_Get_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_State_Get_Args::type_id"]
        [::std::mem::offset_of!(XLA_FFI_State_Get_Args, type_id) - 24usize];
    ["Offset of field: XLA_FFI_State_Get_Args::state"][::std::mem::offset_of!(XLA_FFI_State_Get_Args, state) - 32usize];
};
pub const XLA_FFI_State_Get_Args_STRUCT_SIZE: _bindgen_ty_195 = 40;
pub type _bindgen_ty_195 = ::std::os::raw::c_uint;
pub type XLA_FFI_State_Get =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_State_Get_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Stream_Get_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub stream: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Stream_Get_Args"][::std::mem::size_of::<XLA_FFI_Stream_Get_Args>() - 32usize];
    ["Alignment of XLA_FFI_Stream_Get_Args"][::std::mem::align_of::<XLA_FFI_Stream_Get_Args>() - 8usize];
    ["Offset of field: XLA_FFI_Stream_Get_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_Stream_Get_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Stream_Get_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_Stream_Get_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Stream_Get_Args::ctx"][::std::mem::offset_of!(XLA_FFI_Stream_Get_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_Stream_Get_Args::stream"]
        [::std::mem::offset_of!(XLA_FFI_Stream_Get_Args, stream) - 24usize];
};
pub const XLA_FFI_Stream_Get_Args_STRUCT_SIZE: _bindgen_ty_196 = 32;
pub type _bindgen_ty_196 = ::std::os::raw::c_uint;
pub type XLA_FFI_Stream_Get =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_Stream_Get_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_DeviceMemory_Allocate_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub size: usize,
    pub alignment: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_DeviceMemory_Allocate_Args"]
        [::std::mem::size_of::<XLA_FFI_DeviceMemory_Allocate_Args>() - 48usize];
    ["Alignment of XLA_FFI_DeviceMemory_Allocate_Args"]
        [::std::mem::align_of::<XLA_FFI_DeviceMemory_Allocate_Args>() - 8usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Allocate_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Allocate_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Allocate_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Allocate_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Allocate_Args::ctx"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Allocate_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Allocate_Args::size"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Allocate_Args, size) - 24usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Allocate_Args::alignment"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Allocate_Args, alignment) - 32usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Allocate_Args::data"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Allocate_Args, data) - 40usize];
};
pub const XLA_FFI_DeviceMemory_Allocate_Args_STRUCT_SIZE: _bindgen_ty_197 = 48;
pub type _bindgen_ty_197 = ::std::os::raw::c_uint;
pub type XLA_FFI_DeviceMemory_Allocate =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_DeviceMemory_Allocate_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_DeviceMemory_Free_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub size: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_DeviceMemory_Free_Args"][::std::mem::size_of::<XLA_FFI_DeviceMemory_Free_Args>() - 40usize];
    ["Alignment of XLA_FFI_DeviceMemory_Free_Args"][::std::mem::align_of::<XLA_FFI_DeviceMemory_Free_Args>() - 8usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Free_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Free_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Free_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Free_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Free_Args::ctx"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Free_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Free_Args::size"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Free_Args, size) - 24usize];
    ["Offset of field: XLA_FFI_DeviceMemory_Free_Args::data"]
        [::std::mem::offset_of!(XLA_FFI_DeviceMemory_Free_Args, data) - 32usize];
};
pub const XLA_FFI_DeviceMemory_Free_Args_STRUCT_SIZE: _bindgen_ty_198 = 40;
pub type _bindgen_ty_198 = ::std::os::raw::c_uint;
pub type XLA_FFI_DeviceMemory_Free =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_DeviceMemory_Free_Args) -> *mut XLA_FFI_Error>;
pub type XLA_FFI_Task = ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_ThreadPool_Schedule_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub task: XLA_FFI_Task,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_ThreadPool_Schedule_Args"][::std::mem::size_of::<XLA_FFI_ThreadPool_Schedule_Args>() - 40usize];
    ["Alignment of XLA_FFI_ThreadPool_Schedule_Args"]
        [::std::mem::align_of::<XLA_FFI_ThreadPool_Schedule_Args>() - 8usize];
    ["Offset of field: XLA_FFI_ThreadPool_Schedule_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_Schedule_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_ThreadPool_Schedule_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_Schedule_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_ThreadPool_Schedule_Args::ctx"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_Schedule_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_ThreadPool_Schedule_Args::task"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_Schedule_Args, task) - 24usize];
    ["Offset of field: XLA_FFI_ThreadPool_Schedule_Args::data"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_Schedule_Args, data) - 32usize];
};
pub const XLA_FFI_ThreadPool_Schedule_Args_STRUCT_SIZE: _bindgen_ty_199 = 40;
pub type _bindgen_ty_199 = ::std::os::raw::c_uint;
pub type XLA_FFI_ThreadPool_Schedule =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_ThreadPool_Schedule_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_ThreadPool_NumThreads_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub num_threads: *mut i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_ThreadPool_NumThreads_Args"]
        [::std::mem::size_of::<XLA_FFI_ThreadPool_NumThreads_Args>() - 32usize];
    ["Alignment of XLA_FFI_ThreadPool_NumThreads_Args"]
        [::std::mem::align_of::<XLA_FFI_ThreadPool_NumThreads_Args>() - 8usize];
    ["Offset of field: XLA_FFI_ThreadPool_NumThreads_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_NumThreads_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_ThreadPool_NumThreads_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_NumThreads_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_ThreadPool_NumThreads_Args::ctx"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_NumThreads_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_ThreadPool_NumThreads_Args::num_threads"]
        [::std::mem::offset_of!(XLA_FFI_ThreadPool_NumThreads_Args, num_threads) - 24usize];
};
pub const XLA_FFI_ThreadPool_NumThreads_Args_STRUCT_SIZE: _bindgen_ty_200 = 32;
pub type _bindgen_ty_200 = ::std::os::raw::c_uint;
pub type XLA_FFI_ThreadPool_NumThreads =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_ThreadPool_NumThreads_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_RunId_Get_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub run_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_RunId_Get_Args"][::std::mem::size_of::<XLA_FFI_RunId_Get_Args>() - 32usize];
    ["Alignment of XLA_FFI_RunId_Get_Args"][::std::mem::align_of::<XLA_FFI_RunId_Get_Args>() - 8usize];
    ["Offset of field: XLA_FFI_RunId_Get_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_RunId_Get_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_RunId_Get_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_RunId_Get_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_RunId_Get_Args::ctx"][::std::mem::offset_of!(XLA_FFI_RunId_Get_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_RunId_Get_Args::run_id"]
        [::std::mem::offset_of!(XLA_FFI_RunId_Get_Args, run_id) - 24usize];
};
pub const XLA_FFI_RunId_Get_Args_STRUCT_SIZE: _bindgen_ty_201 = 32;
pub type _bindgen_ty_201 = ::std::os::raw::c_uint;
pub type XLA_FFI_RunId_Get =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_RunId_Get_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_DeviceOrdinal_Get_Args {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub ctx: *mut XLA_FFI_ExecutionContext,
    pub device_ordinal: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_DeviceOrdinal_Get_Args"][::std::mem::size_of::<XLA_FFI_DeviceOrdinal_Get_Args>() - 32usize];
    ["Alignment of XLA_FFI_DeviceOrdinal_Get_Args"][::std::mem::align_of::<XLA_FFI_DeviceOrdinal_Get_Args>() - 8usize];
    ["Offset of field: XLA_FFI_DeviceOrdinal_Get_Args::struct_size"]
        [::std::mem::offset_of!(XLA_FFI_DeviceOrdinal_Get_Args, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_DeviceOrdinal_Get_Args::extension_start"]
        [::std::mem::offset_of!(XLA_FFI_DeviceOrdinal_Get_Args, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_DeviceOrdinal_Get_Args::ctx"]
        [::std::mem::offset_of!(XLA_FFI_DeviceOrdinal_Get_Args, ctx) - 16usize];
    ["Offset of field: XLA_FFI_DeviceOrdinal_Get_Args::device_ordinal"]
        [::std::mem::offset_of!(XLA_FFI_DeviceOrdinal_Get_Args, device_ordinal) - 24usize];
};
pub const XLA_FFI_DeviceOrdinal_Get_Args_STRUCT_SIZE: _bindgen_ty_202 = 28;
pub type _bindgen_ty_202 = ::std::os::raw::c_uint;
pub type XLA_FFI_DeviceOrdinal_Get =
    ::std::option::Option<unsafe extern "C" fn(args: *mut XLA_FFI_DeviceOrdinal_Get_Args) -> *mut XLA_FFI_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Metadata {
    pub struct_size: usize,
    pub api_version: XLA_FFI_Api_Version,
    pub traits: XLA_FFI_Handler_Traits,
    pub state_type_id: XLA_FFI_TypeId,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Metadata"][::std::mem::size_of::<XLA_FFI_Metadata>() - 48usize];
    ["Alignment of XLA_FFI_Metadata"][::std::mem::align_of::<XLA_FFI_Metadata>() - 8usize];
    ["Offset of field: XLA_FFI_Metadata::struct_size"][::std::mem::offset_of!(XLA_FFI_Metadata, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Metadata::api_version"][::std::mem::offset_of!(XLA_FFI_Metadata, api_version) - 8usize];
    ["Offset of field: XLA_FFI_Metadata::traits"][::std::mem::offset_of!(XLA_FFI_Metadata, traits) - 32usize];
    ["Offset of field: XLA_FFI_Metadata::state_type_id"]
        [::std::mem::offset_of!(XLA_FFI_Metadata, state_type_id) - 40usize];
};
pub const XLA_FFI_Metadata_STRUCT_SIZE: _bindgen_ty_203 = 36;
pub type _bindgen_ty_203 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Metadata_Extension {
    pub extension_base: XLA_FFI_Extension_Base,
    pub metadata: *mut XLA_FFI_Metadata,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Metadata_Extension"][::std::mem::size_of::<XLA_FFI_Metadata_Extension>() - 32usize];
    ["Alignment of XLA_FFI_Metadata_Extension"][::std::mem::align_of::<XLA_FFI_Metadata_Extension>() - 8usize];
    ["Offset of field: XLA_FFI_Metadata_Extension::extension_base"]
        [::std::mem::offset_of!(XLA_FFI_Metadata_Extension, extension_base) - 0usize];
    ["Offset of field: XLA_FFI_Metadata_Extension::metadata"]
        [::std::mem::offset_of!(XLA_FFI_Metadata_Extension, metadata) - 24usize];
};
pub const XLA_FFI_Metadata_Extension_STRUCT_SIZE: _bindgen_ty_204 = 32;
pub type _bindgen_ty_204 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLA_FFI_Api {
    pub struct_size: usize,
    pub extension_start: *mut XLA_FFI_Extension_Base,
    pub api_version: XLA_FFI_Api_Version,
    pub internal_api: *const XLA_FFI_InternalApi,
    pub XLA_FFI_Error_Create: XLA_FFI_Error_Create,
    pub XLA_FFI_Error_GetMessage: XLA_FFI_Error_GetMessage,
    pub XLA_FFI_Error_Destroy: XLA_FFI_Error_Destroy,
    pub XLA_FFI_Handler_Register: XLA_FFI_Handler_Register,
    pub XLA_FFI_Stream_Get: XLA_FFI_Stream_Get,
    pub XLA_FFI_Type_Register: XLA_FFI_Type_Register,
    pub XLA_FFI_ExecutionContext_Get: XLA_FFI_ExecutionContext_Get,
    pub XLA_FFI_State_Set: XLA_FFI_State_Set,
    pub XLA_FFI_State_Get: XLA_FFI_State_Get,
    pub XLA_FFI_DeviceMemory_Allocate: XLA_FFI_DeviceMemory_Allocate,
    pub XLA_FFI_DeviceMemory_Free: XLA_FFI_DeviceMemory_Free,
    pub XLA_FFI_ThreadPool_Schedule: XLA_FFI_ThreadPool_Schedule,
    pub XLA_FFI_ThreadPool_NumThreads: XLA_FFI_ThreadPool_NumThreads,
    pub XLA_FFI_Future_Create: XLA_FFI_Future_Create,
    pub XLA_FFI_Future_SetAvailable: XLA_FFI_Future_SetAvailable,
    pub XLA_FFI_Future_SetError: XLA_FFI_Future_SetError,
    pub XLA_FFI_RunId_Get: XLA_FFI_RunId_Get,
    pub XLA_FFI_DeviceOrdinal_Get: XLA_FFI_DeviceOrdinal_Get,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XLA_FFI_Api"][::std::mem::size_of::<XLA_FFI_Api>() - 192usize];
    ["Alignment of XLA_FFI_Api"][::std::mem::align_of::<XLA_FFI_Api>() - 8usize];
    ["Offset of field: XLA_FFI_Api::struct_size"][::std::mem::offset_of!(XLA_FFI_Api, struct_size) - 0usize];
    ["Offset of field: XLA_FFI_Api::extension_start"][::std::mem::offset_of!(XLA_FFI_Api, extension_start) - 8usize];
    ["Offset of field: XLA_FFI_Api::api_version"][::std::mem::offset_of!(XLA_FFI_Api, api_version) - 16usize];
    ["Offset of field: XLA_FFI_Api::internal_api"][::std::mem::offset_of!(XLA_FFI_Api, internal_api) - 40usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Error_Create"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Error_Create) - 48usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Error_GetMessage"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Error_GetMessage) - 56usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Error_Destroy"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Error_Destroy) - 64usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Handler_Register"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Handler_Register) - 72usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Stream_Get"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Stream_Get) - 80usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Type_Register"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Type_Register) - 88usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_ExecutionContext_Get"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_ExecutionContext_Get) - 96usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_State_Set"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_State_Set) - 104usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_State_Get"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_State_Get) - 112usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_DeviceMemory_Allocate"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_DeviceMemory_Allocate) - 120usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_DeviceMemory_Free"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_DeviceMemory_Free) - 128usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_ThreadPool_Schedule"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_ThreadPool_Schedule) - 136usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_ThreadPool_NumThreads"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_ThreadPool_NumThreads) - 144usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Future_Create"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Future_Create) - 152usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Future_SetAvailable"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Future_SetAvailable) - 160usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_Future_SetError"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_Future_SetError) - 168usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_RunId_Get"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_RunId_Get) - 176usize];
    ["Offset of field: XLA_FFI_Api::XLA_FFI_DeviceOrdinal_Get"]
        [::std::mem::offset_of!(XLA_FFI_Api, XLA_FFI_DeviceOrdinal_Get) - 184usize];
};
pub const XLA_FFI_Api_STRUCT_SIZE: _bindgen_ty_205 = 192;
pub type _bindgen_ty_205 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn XLA_FFI_GetApi() -> *const XLA_FFI_Api;
}
#[doc = " Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLlvmThreadPool {
    #[doc = " Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly."]
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirLlvmThreadPool"][::std::mem::size_of::<MlirLlvmThreadPool>() - 8usize];
    ["Alignment of MlirLlvmThreadPool"][::std::mem::align_of::<MlirLlvmThreadPool>() - 8usize];
    ["Offset of field: MlirLlvmThreadPool::ptr"][::std::mem::offset_of!(MlirLlvmThreadPool, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTypeID {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirTypeID"][::std::mem::size_of::<MlirTypeID>() - 8usize];
    ["Alignment of MlirTypeID"][::std::mem::align_of::<MlirTypeID>() - 8usize];
    ["Offset of field: MlirTypeID::ptr"][::std::mem::offset_of!(MlirTypeID, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTypeIDAllocator {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirTypeIDAllocator"][::std::mem::size_of::<MlirTypeIDAllocator>() - 8usize];
    ["Alignment of MlirTypeIDAllocator"][::std::mem::align_of::<MlirTypeIDAllocator>() - 8usize];
    ["Offset of field: MlirTypeIDAllocator::ptr"][::std::mem::offset_of!(MlirTypeIDAllocator, ptr) - 0usize];
};
#[doc = " A pointer to a sized fragment of a string, not necessarily null-terminated.\n Does not own the underlying string. This is equivalent to llvm::StringRef."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirStringRef {
    #[doc = "< Pointer to the first symbol."]
    pub data: *const ::std::os::raw::c_char,
    #[doc = "< Length of the fragment."]
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirStringRef"][::std::mem::size_of::<MlirStringRef>() - 16usize];
    ["Alignment of MlirStringRef"][::std::mem::align_of::<MlirStringRef>() - 8usize];
    ["Offset of field: MlirStringRef::data"][::std::mem::offset_of!(MlirStringRef, data) - 0usize];
    ["Offset of field: MlirStringRef::length"][::std::mem::offset_of!(MlirStringRef, length) - 8usize];
};
unsafe extern "C" {
    #[doc = " Constructs a string reference from a null-terminated C string. Prefer\n mlirStringRefCreate if the length of the string is known."]
    pub fn mlirStringRefCreateFromCString(str_: *const ::std::os::raw::c_char) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns true if two string references are equal, false otherwise."]
    pub fn mlirStringRefEqual(string: MlirStringRef, other: MlirStringRef) -> bool;
}
#[doc = " A callback for returning string references.\n\n This function is called back by the functions that need to return a\n reference to the portion of the string with the following arguments:\n  - an MlirStringRef representing the current portion of the string\n  - a pointer to user data forwarded from the printing call."]
pub type MlirStringCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: MlirStringRef, arg2: *mut ::std::os::raw::c_void)>;
#[doc = " A logical result value, essentially a boolean with named states. LLVM\n convention for using boolean values to designate success or failure of an\n operation is a moving target, so MLIR opted for an explicit class.\n Instances of MlirLogicalResult must only be inspected using the associated\n functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLogicalResult {
    pub value: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirLogicalResult"][::std::mem::size_of::<MlirLogicalResult>() - 1usize];
    ["Alignment of MlirLogicalResult"][::std::mem::align_of::<MlirLogicalResult>() - 1usize];
    ["Offset of field: MlirLogicalResult::value"][::std::mem::offset_of!(MlirLogicalResult, value) - 0usize];
};
unsafe extern "C" {
    #[doc = " Create an LLVM thread pool. This is reexported here to avoid directly\n pulling in the LLVM headers directly."]
    pub fn mlirLlvmThreadPoolCreate() -> MlirLlvmThreadPool;
}
unsafe extern "C" {
    #[doc = " Destroy an LLVM thread pool."]
    pub fn mlirLlvmThreadPoolDestroy(pool: MlirLlvmThreadPool);
}
unsafe extern "C" {
    #[doc = " `ptr` must be 8 byte aligned and unique to a type valid for the duration of\n the returned type id's usage"]
    pub fn mlirTypeIDCreate(ptr: *const ::std::os::raw::c_void) -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks if two type ids are equal."]
    pub fn mlirTypeIDEqual(typeID1: MlirTypeID, typeID2: MlirTypeID) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the hash value of the type id."]
    pub fn mlirTypeIDHashValue(typeID: MlirTypeID) -> usize;
}
unsafe extern "C" {
    #[doc = " Creates a type id allocator for dynamic type id creation"]
    pub fn mlirTypeIDAllocatorCreate() -> MlirTypeIDAllocator;
}
unsafe extern "C" {
    #[doc = " Deallocates the allocator and all allocated type ids"]
    pub fn mlirTypeIDAllocatorDestroy(allocator: MlirTypeIDAllocator);
}
unsafe extern "C" {
    #[doc = " Allocates a type id that is valid for the lifetime of the allocator"]
    pub fn mlirTypeIDAllocatorAllocateTypeID(allocator: MlirTypeIDAllocator) -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirRegisterAllXlaSdyPassesAndPipelines();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAsmState {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirAsmState"][::std::mem::size_of::<MlirAsmState>() - 8usize];
    ["Alignment of MlirAsmState"][::std::mem::align_of::<MlirAsmState>() - 8usize];
    ["Offset of field: MlirAsmState::ptr"][::std::mem::offset_of!(MlirAsmState, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirBytecodeWriterConfig {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirBytecodeWriterConfig"][::std::mem::size_of::<MlirBytecodeWriterConfig>() - 8usize];
    ["Alignment of MlirBytecodeWriterConfig"][::std::mem::align_of::<MlirBytecodeWriterConfig>() - 8usize];
    ["Offset of field: MlirBytecodeWriterConfig::ptr"][::std::mem::offset_of!(MlirBytecodeWriterConfig, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirContext {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirContext"][::std::mem::size_of::<MlirContext>() - 8usize];
    ["Alignment of MlirContext"][::std::mem::align_of::<MlirContext>() - 8usize];
    ["Offset of field: MlirContext::ptr"][::std::mem::offset_of!(MlirContext, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialect {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirDialect"][::std::mem::size_of::<MlirDialect>() - 8usize];
    ["Alignment of MlirDialect"][::std::mem::align_of::<MlirDialect>() - 8usize];
    ["Offset of field: MlirDialect::ptr"][::std::mem::offset_of!(MlirDialect, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialectRegistry {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirDialectRegistry"][::std::mem::size_of::<MlirDialectRegistry>() - 8usize];
    ["Alignment of MlirDialectRegistry"][::std::mem::align_of::<MlirDialectRegistry>() - 8usize];
    ["Offset of field: MlirDialectRegistry::ptr"][::std::mem::offset_of!(MlirDialectRegistry, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOperation {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirOperation"][::std::mem::size_of::<MlirOperation>() - 8usize];
    ["Alignment of MlirOperation"][::std::mem::align_of::<MlirOperation>() - 8usize];
    ["Offset of field: MlirOperation::ptr"][::std::mem::offset_of!(MlirOperation, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpOperand {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirOpOperand"][::std::mem::size_of::<MlirOpOperand>() - 8usize];
    ["Alignment of MlirOpOperand"][::std::mem::align_of::<MlirOpOperand>() - 8usize];
    ["Offset of field: MlirOpOperand::ptr"][::std::mem::offset_of!(MlirOpOperand, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpPrintingFlags {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirOpPrintingFlags"][::std::mem::size_of::<MlirOpPrintingFlags>() - 8usize];
    ["Alignment of MlirOpPrintingFlags"][::std::mem::align_of::<MlirOpPrintingFlags>() - 8usize];
    ["Offset of field: MlirOpPrintingFlags::ptr"][::std::mem::offset_of!(MlirOpPrintingFlags, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirBlock {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirBlock"][::std::mem::size_of::<MlirBlock>() - 8usize];
    ["Alignment of MlirBlock"][::std::mem::align_of::<MlirBlock>() - 8usize];
    ["Offset of field: MlirBlock::ptr"][::std::mem::offset_of!(MlirBlock, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRegion {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirRegion"][::std::mem::size_of::<MlirRegion>() - 8usize];
    ["Alignment of MlirRegion"][::std::mem::align_of::<MlirRegion>() - 8usize];
    ["Offset of field: MlirRegion::ptr"][::std::mem::offset_of!(MlirRegion, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirSymbolTable {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirSymbolTable"][::std::mem::size_of::<MlirSymbolTable>() - 8usize];
    ["Alignment of MlirSymbolTable"][::std::mem::align_of::<MlirSymbolTable>() - 8usize];
    ["Offset of field: MlirSymbolTable::ptr"][::std::mem::offset_of!(MlirSymbolTable, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAttribute {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirAttribute"][::std::mem::size_of::<MlirAttribute>() - 8usize];
    ["Alignment of MlirAttribute"][::std::mem::align_of::<MlirAttribute>() - 8usize];
    ["Offset of field: MlirAttribute::ptr"][::std::mem::offset_of!(MlirAttribute, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirIdentifier {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirIdentifier"][::std::mem::size_of::<MlirIdentifier>() - 8usize];
    ["Alignment of MlirIdentifier"][::std::mem::align_of::<MlirIdentifier>() - 8usize];
    ["Offset of field: MlirIdentifier::ptr"][::std::mem::offset_of!(MlirIdentifier, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLocation {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirLocation"][::std::mem::size_of::<MlirLocation>() - 8usize];
    ["Alignment of MlirLocation"][::std::mem::align_of::<MlirLocation>() - 8usize];
    ["Offset of field: MlirLocation::ptr"][::std::mem::offset_of!(MlirLocation, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirModule {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirModule"][::std::mem::size_of::<MlirModule>() - 8usize];
    ["Alignment of MlirModule"][::std::mem::align_of::<MlirModule>() - 8usize];
    ["Offset of field: MlirModule::ptr"][::std::mem::offset_of!(MlirModule, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirType {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirType"][::std::mem::size_of::<MlirType>() - 8usize];
    ["Alignment of MlirType"][::std::mem::align_of::<MlirType>() - 8usize];
    ["Offset of field: MlirType::ptr"][::std::mem::offset_of!(MlirType, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirValue {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirValue"][::std::mem::size_of::<MlirValue>() - 8usize];
    ["Alignment of MlirValue"][::std::mem::align_of::<MlirValue>() - 8usize];
    ["Offset of field: MlirValue::ptr"][::std::mem::offset_of!(MlirValue, ptr) - 0usize];
};
#[doc = " Named MLIR attribute.\n\n A named attribute is essentially a (name, attribute) pair where the name is\n a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirNamedAttribute {
    pub name: MlirIdentifier,
    pub attribute: MlirAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirNamedAttribute"][::std::mem::size_of::<MlirNamedAttribute>() - 16usize];
    ["Alignment of MlirNamedAttribute"][::std::mem::align_of::<MlirNamedAttribute>() - 8usize];
    ["Offset of field: MlirNamedAttribute::name"][::std::mem::offset_of!(MlirNamedAttribute, name) - 0usize];
    ["Offset of field: MlirNamedAttribute::attribute"][::std::mem::offset_of!(MlirNamedAttribute, attribute) - 8usize];
};
unsafe extern "C" {
    #[doc = " Creates an MLIR context and transfers its ownership to the caller.\n This sets the default multithreading option (enabled)."]
    pub fn mlirContextCreate() -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Creates an MLIR context with an explicit setting of the multithreading\n setting and transfers its ownership to the caller."]
    pub fn mlirContextCreateWithThreading(threadingEnabled: bool) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Creates an MLIR context, setting the multithreading setting explicitly and\n pre-loading the dialects from the provided DialectRegistry."]
    pub fn mlirContextCreateWithRegistry(registry: MlirDialectRegistry, threadingEnabled: bool) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Checks if two contexts are equal."]
    pub fn mlirContextEqual(ctx1: MlirContext, ctx2: MlirContext) -> bool;
}
unsafe extern "C" {
    #[doc = " Takes an MLIR context owned by the caller and destroys it."]
    pub fn mlirContextDestroy(context: MlirContext);
}
unsafe extern "C" {
    #[doc = " Sets whether unregistered dialects are allowed in this context."]
    pub fn mlirContextSetAllowUnregisteredDialects(context: MlirContext, allow: bool);
}
unsafe extern "C" {
    #[doc = " Returns whether the context allows unregistered dialects."]
    pub fn mlirContextGetAllowUnregisteredDialects(context: MlirContext) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of dialects registered with the given context. A\n registered dialect will be loaded if needed by the parser."]
    pub fn mlirContextGetNumRegisteredDialects(context: MlirContext) -> isize;
}
unsafe extern "C" {
    #[doc = " Append the contents of the given dialect registry to the registry associated\n with the context."]
    pub fn mlirContextAppendDialectRegistry(ctx: MlirContext, registry: MlirDialectRegistry);
}
unsafe extern "C" {
    #[doc = " Returns the number of dialects loaded by the context."]
    pub fn mlirContextGetNumLoadedDialects(context: MlirContext) -> isize;
}
unsafe extern "C" {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = " Gets the dialect instance owned by the given context using the dialect\n namespace to identify it, loads (i.e., constructs the instance of) the\n dialect if necessary. If the dialect is not registered with the context,\n returns null. Use mlirContextLoad<Name>Dialect to load an unregistered\n dialect."]
    pub fn mlirContextGetOrLoadDialect(context: MlirContext, name: MlirStringRef) -> MlirDialect;
}
unsafe extern "C" {
    #[doc = " Set threading mode (must be set to false to mlir-print-ir-after-all)."]
    pub fn mlirContextEnableMultithreading(context: MlirContext, enable: bool);
}
unsafe extern "C" {
    #[doc = " Eagerly loads all available dialects registered with a context, making\n them available for use for IR construction."]
    pub fn mlirContextLoadAllAvailableDialects(context: MlirContext);
}
unsafe extern "C" {
    #[doc = " Returns whether the given fully-qualified operation (i.e.\n 'dialect.operation') is registered with the context. This will return true\n if the dialect is loaded and the operation is registered within the\n dialect."]
    pub fn mlirContextIsRegisteredOperation(context: MlirContext, name: MlirStringRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Sets the thread pool of the context explicitly, enabling multithreading in\n the process. This API should be used to avoid re-creating thread pools in\n long-running applications that perform multiple compilations, see\n the C++ documentation for MLIRContext for details."]
    pub fn mlirContextSetThreadPool(context: MlirContext, threadPool: MlirLlvmThreadPool);
}
unsafe extern "C" {
    #[doc = " Gets the number of threads of the thread pool of the context when\n multithreading is enabled. Returns 1 if no multithreading."]
    pub fn mlirContextGetNumThreads(context: MlirContext) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Gets the thread pool of the context when enabled multithreading, otherwise\n an assertion is raised."]
    pub fn mlirContextGetThreadPool(context: MlirContext) -> MlirLlvmThreadPool;
}
unsafe extern "C" {
    #[doc = " Returns the context that owns the dialect."]
    pub fn mlirDialectGetContext(dialect: MlirDialect) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Checks if two dialects that belong to the same context are equal. Dialects\n from different contexts will not compare equal."]
    pub fn mlirDialectEqual(dialect1: MlirDialect, dialect2: MlirDialect) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the namespace of the given dialect."]
    pub fn mlirDialectGetNamespace(dialect: MlirDialect) -> MlirStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialectHandle {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirDialectHandle"][::std::mem::size_of::<MlirDialectHandle>() - 8usize];
    ["Alignment of MlirDialectHandle"][::std::mem::align_of::<MlirDialectHandle>() - 8usize];
    ["Offset of field: MlirDialectHandle::ptr"][::std::mem::offset_of!(MlirDialectHandle, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Returns the namespace associated with the provided dialect handle."]
    pub fn mlirDialectHandleGetNamespace(arg1: MlirDialectHandle) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Inserts the dialect associated with the provided dialect handle into the\n provided dialect registry"]
    pub fn mlirDialectHandleInsertDialect(arg1: MlirDialectHandle, arg2: MlirDialectRegistry);
}
unsafe extern "C" {
    #[doc = " Registers the dialect associated with the provided dialect handle."]
    pub fn mlirDialectHandleRegisterDialect(arg1: MlirDialectHandle, arg2: MlirContext);
}
unsafe extern "C" {
    #[doc = " Loads the dialect associated with the provided dialect handle."]
    pub fn mlirDialectHandleLoadDialect(arg1: MlirDialectHandle, arg2: MlirContext) -> MlirDialect;
}
unsafe extern "C" {
    #[doc = " Creates a dialect registry and transfers its ownership to the caller."]
    pub fn mlirDialectRegistryCreate() -> MlirDialectRegistry;
}
unsafe extern "C" {
    #[doc = " Takes a dialect registry owned by the caller and destroys it."]
    pub fn mlirDialectRegistryDestroy(registry: MlirDialectRegistry);
}
unsafe extern "C" {
    #[doc = " Returns the underlying location attribute of this location."]
    pub fn mlirLocationGetAttribute(location: MlirLocation) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a location from a location attribute."]
    pub fn mlirLocationFromAttribute(attribute: MlirAttribute) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Creates an File/Line/Column location owned by the given context."]
    pub fn mlirLocationFileLineColGet(
        context: MlirContext,
        filename: MlirStringRef,
        line: ::std::os::raw::c_uint,
        col: ::std::os::raw::c_uint,
    ) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Creates an File/Line/Column range location owned by the given context."]
    pub fn mlirLocationFileLineColRangeGet(
        context: MlirContext,
        filename: MlirStringRef,
        start_line: ::std::os::raw::c_uint,
        start_col: ::std::os::raw::c_uint,
        end_line: ::std::os::raw::c_uint,
        end_col: ::std::os::raw::c_uint,
    ) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Getter for filename of FileLineColRange."]
    pub fn mlirLocationFileLineColRangeGetFilename(location: MlirLocation) -> MlirIdentifier;
}
unsafe extern "C" {
    #[doc = " Getter for start_line of FileLineColRange."]
    pub fn mlirLocationFileLineColRangeGetStartLine(location: MlirLocation) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Getter for start_column of FileLineColRange."]
    pub fn mlirLocationFileLineColRangeGetStartColumn(location: MlirLocation) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Getter for end_line of FileLineColRange."]
    pub fn mlirLocationFileLineColRangeGetEndLine(location: MlirLocation) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Getter for end_column of FileLineColRange."]
    pub fn mlirLocationFileLineColRangeGetEndColumn(location: MlirLocation) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " TypeID Getter for FileLineColRange."]
    pub fn mlirLocationFileLineColRangeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given location is an FileLineColRange."]
    pub fn mlirLocationIsAFileLineColRange(location: MlirLocation) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a call site location with a callee and a caller."]
    pub fn mlirLocationCallSiteGet(callee: MlirLocation, caller: MlirLocation) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Getter for callee of CallSite."]
    pub fn mlirLocationCallSiteGetCallee(location: MlirLocation) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Getter for caller of CallSite."]
    pub fn mlirLocationCallSiteGetCaller(location: MlirLocation) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " TypeID Getter for CallSite."]
    pub fn mlirLocationCallSiteGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given location is an CallSite."]
    pub fn mlirLocationIsACallSite(location: MlirLocation) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a fused location with an array of locations and metadata."]
    pub fn mlirLocationFusedGet(
        ctx: MlirContext,
        nLocations: isize,
        locations: *const MlirLocation,
        metadata: MlirAttribute,
    ) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Getter for number of locations fused together."]
    pub fn mlirLocationFusedGetNumLocations(location: MlirLocation) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Getter for locations of Fused. Requires pre-allocated memory of\n #fusedLocations X sizeof(MlirLocation)."]
    pub fn mlirLocationFusedGetLocations(location: MlirLocation, locationsCPtr: *mut MlirLocation);
}
unsafe extern "C" {
    #[doc = " Getter for metadata of Fused."]
    pub fn mlirLocationFusedGetMetadata(location: MlirLocation) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " TypeID Getter for Fused."]
    pub fn mlirLocationFusedGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given location is an Fused."]
    pub fn mlirLocationIsAFused(location: MlirLocation) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a name location owned by the given context. Providing null location\n for childLoc is allowed and if childLoc is null location, then the behavior\n is the same as having unknown child location."]
    pub fn mlirLocationNameGet(context: MlirContext, name: MlirStringRef, childLoc: MlirLocation) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Getter for name of Name."]
    pub fn mlirLocationNameGetName(location: MlirLocation) -> MlirIdentifier;
}
unsafe extern "C" {
    #[doc = " Getter for childLoc of Name."]
    pub fn mlirLocationNameGetChildLoc(location: MlirLocation) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " TypeID Getter for Name."]
    pub fn mlirLocationNameGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given location is an Name."]
    pub fn mlirLocationIsAName(location: MlirLocation) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a location with unknown position owned by the given context."]
    pub fn mlirLocationUnknownGet(context: MlirContext) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Gets the context that a location was created with."]
    pub fn mlirLocationGetContext(location: MlirLocation) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Checks if two locations are equal."]
    pub fn mlirLocationEqual(l1: MlirLocation, l2: MlirLocation) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints a location by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirLocationPrint(
        location: MlirLocation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Creates a new, empty module and transfers ownership to the caller."]
    pub fn mlirModuleCreateEmpty(location: MlirLocation) -> MlirModule;
}
unsafe extern "C" {
    #[doc = " Parses a module from the string and transfers ownership to the caller."]
    pub fn mlirModuleCreateParse(context: MlirContext, module: MlirStringRef) -> MlirModule;
}
unsafe extern "C" {
    #[doc = " Parses a module from file and transfers ownership to the caller."]
    pub fn mlirModuleCreateParseFromFile(context: MlirContext, fileName: MlirStringRef) -> MlirModule;
}
unsafe extern "C" {
    #[doc = " Gets the context that a module was created with."]
    pub fn mlirModuleGetContext(module: MlirModule) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Gets the body of the module, i.e. the only block it contains."]
    pub fn mlirModuleGetBody(module: MlirModule) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Takes a module owned by the caller and deletes it."]
    pub fn mlirModuleDestroy(module: MlirModule);
}
unsafe extern "C" {
    #[doc = " Views the module as a generic operation."]
    pub fn mlirModuleGetOperation(module: MlirModule) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Views the generic operation as a module.\n The returned module is null when the input operation was not a ModuleOp."]
    pub fn mlirModuleFromOperation(op: MlirOperation) -> MlirModule;
}
unsafe extern "C" {
    #[doc = " Checks if two modules are equal."]
    pub fn mlirModuleEqual(lhs: MlirModule, rhs: MlirModule) -> bool;
}
unsafe extern "C" {
    #[doc = " Compute a hash for the given module."]
    pub fn mlirModuleHashValue(mod_: MlirModule) -> usize;
}
#[doc = " An auxiliary class for constructing operations.\n\n This class contains all the information necessary to construct the\n operation. It owns the MlirRegions it has pointers to and does not own\n anything else. By default, the state can be constructed from a name and\n location, the latter being also used to access the context, and has no other\n components. These components can be added progressively until the operation\n is constructed. Users are not expected to rely on the internals of this\n class and should use mlirOperationState* functions instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOperationState {
    pub name: MlirStringRef,
    pub location: MlirLocation,
    pub nResults: isize,
    pub results: *mut MlirType,
    pub nOperands: isize,
    pub operands: *mut MlirValue,
    pub nRegions: isize,
    pub regions: *mut MlirRegion,
    pub nSuccessors: isize,
    pub successors: *mut MlirBlock,
    pub nAttributes: isize,
    pub attributes: *mut MlirNamedAttribute,
    pub enableResultTypeInference: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirOperationState"][::std::mem::size_of::<MlirOperationState>() - 112usize];
    ["Alignment of MlirOperationState"][::std::mem::align_of::<MlirOperationState>() - 8usize];
    ["Offset of field: MlirOperationState::name"][::std::mem::offset_of!(MlirOperationState, name) - 0usize];
    ["Offset of field: MlirOperationState::location"][::std::mem::offset_of!(MlirOperationState, location) - 16usize];
    ["Offset of field: MlirOperationState::nResults"][::std::mem::offset_of!(MlirOperationState, nResults) - 24usize];
    ["Offset of field: MlirOperationState::results"][::std::mem::offset_of!(MlirOperationState, results) - 32usize];
    ["Offset of field: MlirOperationState::nOperands"][::std::mem::offset_of!(MlirOperationState, nOperands) - 40usize];
    ["Offset of field: MlirOperationState::operands"][::std::mem::offset_of!(MlirOperationState, operands) - 48usize];
    ["Offset of field: MlirOperationState::nRegions"][::std::mem::offset_of!(MlirOperationState, nRegions) - 56usize];
    ["Offset of field: MlirOperationState::regions"][::std::mem::offset_of!(MlirOperationState, regions) - 64usize];
    ["Offset of field: MlirOperationState::nSuccessors"]
        [::std::mem::offset_of!(MlirOperationState, nSuccessors) - 72usize];
    ["Offset of field: MlirOperationState::successors"]
        [::std::mem::offset_of!(MlirOperationState, successors) - 80usize];
    ["Offset of field: MlirOperationState::nAttributes"]
        [::std::mem::offset_of!(MlirOperationState, nAttributes) - 88usize];
    ["Offset of field: MlirOperationState::attributes"]
        [::std::mem::offset_of!(MlirOperationState, attributes) - 96usize];
    ["Offset of field: MlirOperationState::enableResultTypeInference"]
        [::std::mem::offset_of!(MlirOperationState, enableResultTypeInference) - 104usize];
};
unsafe extern "C" {
    #[doc = " Constructs an operation state from a name and a location."]
    pub fn mlirOperationStateGet(name: MlirStringRef, loc: MlirLocation) -> MlirOperationState;
}
unsafe extern "C" {
    #[doc = " Adds a list of components to the operation state."]
    pub fn mlirOperationStateAddResults(state: *mut MlirOperationState, n: isize, results: *const MlirType);
}
unsafe extern "C" {
    pub fn mlirOperationStateAddOperands(state: *mut MlirOperationState, n: isize, operands: *const MlirValue);
}
unsafe extern "C" {
    pub fn mlirOperationStateAddOwnedRegions(state: *mut MlirOperationState, n: isize, regions: *const MlirRegion);
}
unsafe extern "C" {
    pub fn mlirOperationStateAddSuccessors(state: *mut MlirOperationState, n: isize, successors: *const MlirBlock);
}
unsafe extern "C" {
    pub fn mlirOperationStateAddAttributes(
        state: *mut MlirOperationState,
        n: isize,
        attributes: *const MlirNamedAttribute,
    );
}
unsafe extern "C" {
    #[doc = " Enables result type inference for the operation under construction. If\n enabled, then the caller must not have called\n mlirOperationStateAddResults(). Note that if enabled, the\n mlirOperationCreate() call is failable: it will return a null operation\n on inference failure and will emit diagnostics."]
    pub fn mlirOperationStateEnableResultTypeInference(state: *mut MlirOperationState);
}
unsafe extern "C" {
    #[doc = " Creates new AsmState, as with AsmState the IR should not be mutated\n in-between using this state.\n Must be freed with a call to mlirAsmStateDestroy()."]
    pub fn mlirAsmStateCreateForOperation(op: MlirOperation, flags: MlirOpPrintingFlags) -> MlirAsmState;
}
unsafe extern "C" {
    #[doc = " Creates new AsmState from value.\n Must be freed with a call to mlirAsmStateDestroy()."]
    pub fn mlirAsmStateCreateForValue(value: MlirValue, flags: MlirOpPrintingFlags) -> MlirAsmState;
}
unsafe extern "C" {
    #[doc = " Destroys printing flags created with mlirAsmStateCreate."]
    pub fn mlirAsmStateDestroy(state: MlirAsmState);
}
unsafe extern "C" {
    #[doc = " Creates new printing flags with defaults, intended for customization.\n Must be freed with a call to mlirOpPrintingFlagsDestroy()."]
    pub fn mlirOpPrintingFlagsCreate() -> MlirOpPrintingFlags;
}
unsafe extern "C" {
    #[doc = " Destroys printing flags created with mlirOpPrintingFlagsCreate."]
    pub fn mlirOpPrintingFlagsDestroy(flags: MlirOpPrintingFlags);
}
unsafe extern "C" {
    #[doc = " Enables the elision of large elements attributes by printing a lexically\n valid but otherwise meaningless form instead of the element data. The\n `largeElementLimit` is used to configure what is considered to be a \"large\"\n ElementsAttr by providing an upper limit to the number of elements."]
    pub fn mlirOpPrintingFlagsElideLargeElementsAttrs(flags: MlirOpPrintingFlags, largeElementLimit: isize);
}
unsafe extern "C" {
    #[doc = " Enables the elision of large resources strings by omitting them from the\n `dialect_resources` section. The `largeResourceLimit` is used to configure\n what is considered to be a \"large\" resource by providing an upper limit to\n the string size."]
    pub fn mlirOpPrintingFlagsElideLargeResourceString(flags: MlirOpPrintingFlags, largeResourceLimit: isize);
}
unsafe extern "C" {
    #[doc = " Enable or disable printing of debug information (based on `enable`). If\n 'prettyForm' is set to true, debug information is printed in a more readable\n 'pretty' form. Note: The IR generated with 'prettyForm' is not parsable."]
    pub fn mlirOpPrintingFlagsEnableDebugInfo(flags: MlirOpPrintingFlags, enable: bool, prettyForm: bool);
}
unsafe extern "C" {
    #[doc = " Always print operations in the generic form."]
    pub fn mlirOpPrintingFlagsPrintGenericOpForm(flags: MlirOpPrintingFlags);
}
unsafe extern "C" {
    #[doc = " Print the name and location, if NamedLoc, as a prefix to the SSA ID."]
    pub fn mlirOpPrintingFlagsPrintNameLocAsPrefix(flags: MlirOpPrintingFlags);
}
unsafe extern "C" {
    #[doc = " Use local scope when printing the operation. This allows for using the\n printer in a more localized and thread-safe setting, but may not\n necessarily be identical to what the IR will look like when dumping\n the full module."]
    pub fn mlirOpPrintingFlagsUseLocalScope(flags: MlirOpPrintingFlags);
}
unsafe extern "C" {
    #[doc = " Do not verify the operation when using custom operation printers."]
    pub fn mlirOpPrintingFlagsAssumeVerified(flags: MlirOpPrintingFlags);
}
unsafe extern "C" {
    #[doc = " Skip printing regions."]
    pub fn mlirOpPrintingFlagsSkipRegions(flags: MlirOpPrintingFlags);
}
unsafe extern "C" {
    #[doc = " Creates new printing flags with defaults, intended for customization.\n Must be freed with a call to mlirBytecodeWriterConfigDestroy()."]
    pub fn mlirBytecodeWriterConfigCreate() -> MlirBytecodeWriterConfig;
}
unsafe extern "C" {
    #[doc = " Destroys printing flags created with mlirBytecodeWriterConfigCreate."]
    pub fn mlirBytecodeWriterConfigDestroy(config: MlirBytecodeWriterConfig);
}
unsafe extern "C" {
    #[doc = " Sets the version to emit in the writer config."]
    pub fn mlirBytecodeWriterConfigDesiredEmitVersion(flags: MlirBytecodeWriterConfig, version: i64);
}
unsafe extern "C" {
    #[doc = " Creates an operation and transfers ownership to the caller.\n Note that caller owned child objects are transferred in this call and must\n not be further used. Particularly, this applies to any regions added to\n the state (the implementation may invalidate any such pointers).\n\n This call can fail under the following conditions, in which case, it will\n return a null operation and emit diagnostics:\n   - Result type inference is enabled and cannot be performed."]
    pub fn mlirOperationCreate(state: *mut MlirOperationState) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Parses an operation, giving ownership to the caller. If parsing fails a null\n operation will be returned, and an error diagnostic emitted.\n\n `sourceStr` may be either the text assembly format, or binary bytecode\n format. `sourceName` is used as the file name of the source; any IR without\n locations will get a `FileLineColLoc` location with `sourceName` as the file\n name."]
    pub fn mlirOperationCreateParse(
        context: MlirContext,
        sourceStr: MlirStringRef,
        sourceName: MlirStringRef,
    ) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Creates a deep copy of an operation. The operation is not inserted and\n ownership is transferred to the caller."]
    pub fn mlirOperationClone(op: MlirOperation) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Takes an operation owned by the caller and destroys it."]
    pub fn mlirOperationDestroy(op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Removes the given operation from its parent block. The operation is not\n destroyed. The ownership of the operation is transferred to the caller."]
    pub fn mlirOperationRemoveFromParent(op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Checks whether two operation handles point to the same operation. This does\n not perform deep comparison."]
    pub fn mlirOperationEqual(op: MlirOperation, other: MlirOperation) -> bool;
}
unsafe extern "C" {
    #[doc = " Compute a hash for the given operation."]
    pub fn mlirOperationHashValue(op: MlirOperation) -> usize;
}
unsafe extern "C" {
    #[doc = " Gets the context this operation is associated with"]
    pub fn mlirOperationGetContext(op: MlirOperation) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Gets the location of the operation."]
    pub fn mlirOperationGetLocation(op: MlirOperation) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Sets the location of the operation."]
    pub fn mlirOperationSetLocation(op: MlirOperation, loc: MlirLocation);
}
unsafe extern "C" {
    #[doc = " Gets the type id of the operation.\n Returns null if the operation does not have a registered operation\n description."]
    pub fn mlirOperationGetTypeID(op: MlirOperation) -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Gets the name of the operation as an identifier."]
    pub fn mlirOperationGetName(op: MlirOperation) -> MlirIdentifier;
}
unsafe extern "C" {
    #[doc = " Gets the block that owns this operation, returning null if the operation is\n not owned."]
    pub fn mlirOperationGetBlock(op: MlirOperation) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Gets the operation that owns this operation, returning null if the operation\n is not owned."]
    pub fn mlirOperationGetParentOperation(op: MlirOperation) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Returns the number of regions attached to the given operation."]
    pub fn mlirOperationGetNumRegions(op: MlirOperation) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th region attached to the operation."]
    pub fn mlirOperationGetRegion(op: MlirOperation, pos: isize) -> MlirRegion;
}
unsafe extern "C" {
    #[doc = " Returns an operation immediately following the given operation it its\n enclosing block."]
    pub fn mlirOperationGetNextInBlock(op: MlirOperation) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Returns the number of operands of the operation."]
    pub fn mlirOperationGetNumOperands(op: MlirOperation) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th operand of the operation."]
    pub fn mlirOperationGetOperand(op: MlirOperation, pos: isize) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Sets the `pos`-th operand of the operation."]
    pub fn mlirOperationSetOperand(op: MlirOperation, pos: isize, newValue: MlirValue);
}
unsafe extern "C" {
    #[doc = " Replaces the operands of the operation."]
    pub fn mlirOperationSetOperands(op: MlirOperation, nOperands: isize, operands: *const MlirValue);
}
unsafe extern "C" {
    #[doc = " Returns the number of results of the operation."]
    pub fn mlirOperationGetNumResults(op: MlirOperation) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th result of the operation."]
    pub fn mlirOperationGetResult(op: MlirOperation, pos: isize) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Returns the number of successor blocks of the operation."]
    pub fn mlirOperationGetNumSuccessors(op: MlirOperation) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th successor of the operation."]
    pub fn mlirOperationGetSuccessor(op: MlirOperation, pos: isize) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Set `pos`-th successor of the operation."]
    pub fn mlirOperationSetSuccessor(op: MlirOperation, pos: isize, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Returns true if this operation defines an inherent attribute with this name.\n Note: the attribute can be optional, so\n `mlirOperationGetInherentAttributeByName` can still return a null attribute."]
    pub fn mlirOperationHasInherentAttributeByName(op: MlirOperation, name: MlirStringRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns an inherent attribute attached to the operation given its name."]
    pub fn mlirOperationGetInherentAttributeByName(op: MlirOperation, name: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Sets an inherent attribute by name, replacing the existing if it exists.\n This has no effect if \"name\" does not match an inherent attribute."]
    pub fn mlirOperationSetInherentAttributeByName(op: MlirOperation, name: MlirStringRef, attr: MlirAttribute);
}
unsafe extern "C" {
    #[doc = " Returns the number of discardable attributes attached to the operation."]
    pub fn mlirOperationGetNumDiscardableAttributes(op: MlirOperation) -> isize;
}
unsafe extern "C" {
    #[doc = " Return `pos`-th discardable attribute of the operation."]
    pub fn mlirOperationGetDiscardableAttribute(op: MlirOperation, pos: isize) -> MlirNamedAttribute;
}
unsafe extern "C" {
    #[doc = " Returns a discardable attribute attached to the operation given its name."]
    pub fn mlirOperationGetDiscardableAttributeByName(op: MlirOperation, name: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Sets a discardable attribute by name, replacing the existing if it exists or\n adding a new one otherwise. The new `attr` Attribute is not allowed to be\n null, use `mlirOperationRemoveDiscardableAttributeByName` to remove an\n Attribute instead."]
    pub fn mlirOperationSetDiscardableAttributeByName(op: MlirOperation, name: MlirStringRef, attr: MlirAttribute);
}
unsafe extern "C" {
    #[doc = " Removes a discardable attribute by name. Returns false if the attribute was\n not found and true if removed."]
    pub fn mlirOperationRemoveDiscardableAttributeByName(op: MlirOperation, name: MlirStringRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of attributes attached to the operation.\n Deprecated, please use `mlirOperationGetNumInherentAttributes` or\n `mlirOperationGetNumDiscardableAttributes`."]
    pub fn mlirOperationGetNumAttributes(op: MlirOperation) -> isize;
}
unsafe extern "C" {
    #[doc = " Return `pos`-th attribute of the operation.\n Deprecated, please use `mlirOperationGetInherentAttribute` or\n `mlirOperationGetDiscardableAttribute`."]
    pub fn mlirOperationGetAttribute(op: MlirOperation, pos: isize) -> MlirNamedAttribute;
}
unsafe extern "C" {
    #[doc = " Returns an attribute attached to the operation given its name.\n Deprecated, please use `mlirOperationGetInherentAttributeByName` or\n `mlirOperationGetDiscardableAttributeByName`."]
    pub fn mlirOperationGetAttributeByName(op: MlirOperation, name: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Sets an attribute by name, replacing the existing if it exists or\n adding a new one otherwise.\n Deprecated, please use `mlirOperationSetInherentAttributeByName` or\n `mlirOperationSetDiscardableAttributeByName`."]
    pub fn mlirOperationSetAttributeByName(op: MlirOperation, name: MlirStringRef, attr: MlirAttribute);
}
unsafe extern "C" {
    #[doc = " Removes an attribute by name. Returns false if the attribute was not found\n and true if removed.\n Deprecated, please use `mlirOperationRemoveInherentAttributeByName` or\n `mlirOperationRemoveDiscardableAttributeByName`."]
    pub fn mlirOperationRemoveAttributeByName(op: MlirOperation, name: MlirStringRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints an operation by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirOperationPrint(op: MlirOperation, callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Same as mlirOperationPrint but accepts flags controlling the printing\n behavior."]
    pub fn mlirOperationPrintWithFlags(
        op: MlirOperation,
        flags: MlirOpPrintingFlags,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Same as mlirOperationPrint but accepts AsmState controlling the printing\n behavior as well as caching computed names."]
    pub fn mlirOperationPrintWithState(
        op: MlirOperation,
        state: MlirAsmState,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Same as mlirOperationPrint but writing the bytecode format."]
    pub fn mlirOperationWriteBytecode(
        op: MlirOperation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Same as mlirOperationWriteBytecode but with writer config and returns\n failure only if desired bytecode could not be honored."]
    pub fn mlirOperationWriteBytecodeWithConfig(
        op: MlirOperation,
        config: MlirBytecodeWriterConfig,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Prints an operation to stderr."]
    pub fn mlirOperationDump(op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Verify the operation and return true if it passes, false if it fails."]
    pub fn mlirOperationVerify(op: MlirOperation) -> bool;
}
unsafe extern "C" {
    #[doc = " Moves the given operation immediately after the other operation in its\n parent block. The given operation may be owned by the caller or by its\n current block. The other operation must belong to a block. In any case, the\n ownership is transferred to the block of the other operation."]
    pub fn mlirOperationMoveAfter(op: MlirOperation, other: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Moves the given operation immediately before the other operation in its\n parent block. The given operation may be owner by the caller or by its\n current block. The other operation must belong to a block. In any case, the\n ownership is transferred to the block of the other operation."]
    pub fn mlirOperationMoveBefore(op: MlirOperation, other: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Given an operation 'other' that is within the same parent block, return\n whether the current operation is before 'other' in the operation list\n of the parent block.\n Note: This function has an average complexity of O(1), but worst case may\n take O(N) where N is the number of operations within the parent block."]
    pub fn mlirOperationIsBeforeInBlock(op: MlirOperation, other: MlirOperation) -> bool;
}
pub const MlirWalkResult_MlirWalkResultAdvance: MlirWalkResult = 0;
pub const MlirWalkResult_MlirWalkResultInterrupt: MlirWalkResult = 1;
pub const MlirWalkResult_MlirWalkResultSkip: MlirWalkResult = 2;
#[doc = " Operation walk result."]
pub type MlirWalkResult = ::std::os::raw::c_uint;
pub const MlirWalkOrder_MlirWalkPreOrder: MlirWalkOrder = 0;
pub const MlirWalkOrder_MlirWalkPostOrder: MlirWalkOrder = 1;
#[doc = " Traversal order for operation walk."]
pub type MlirWalkOrder = ::std::os::raw::c_uint;
#[doc = " Operation walker type. The handler is passed an (opaque) reference to an\n operation and a pointer to a `userData`."]
pub type MlirOperationWalkCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: MlirOperation, userData: *mut ::std::os::raw::c_void) -> MlirWalkResult,
>;
unsafe extern "C" {
    #[doc = " Walks operation `op` in `walkOrder` and calls `callback` on that operation.\n `*userData` is passed to the callback as well and can be used to tunnel some\n context or other data into the callback."]
    pub fn mlirOperationWalk(
        op: MlirOperation,
        callback: MlirOperationWalkCallback,
        userData: *mut ::std::os::raw::c_void,
        walkOrder: MlirWalkOrder,
    );
}
unsafe extern "C" {
    #[doc = " Replace uses of 'of' value with the 'with' value inside the 'op' operation."]
    pub fn mlirOperationReplaceUsesOfWith(op: MlirOperation, of: MlirValue, with: MlirValue);
}
unsafe extern "C" {
    #[doc = " Creates a new empty region and transfers ownership to the caller."]
    pub fn mlirRegionCreate() -> MlirRegion;
}
unsafe extern "C" {
    #[doc = " Takes a region owned by the caller and destroys it."]
    pub fn mlirRegionDestroy(region: MlirRegion);
}
unsafe extern "C" {
    #[doc = " Checks whether two region handles point to the same region. This does not\n perform deep comparison."]
    pub fn mlirRegionEqual(region: MlirRegion, other: MlirRegion) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the first block in the region."]
    pub fn mlirRegionGetFirstBlock(region: MlirRegion) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Takes a block owned by the caller and appends it to the given region."]
    pub fn mlirRegionAppendOwnedBlock(region: MlirRegion, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it at `pos` to the given\n region. This is an expensive operation that linearly scans the region,\n prefer insertAfter/Before instead."]
    pub fn mlirRegionInsertOwnedBlock(region: MlirRegion, pos: isize, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it after the (non-owned)\n reference block in the given region. The reference block must belong to the\n region. If the reference block is null, prepends the block to the region."]
    pub fn mlirRegionInsertOwnedBlockAfter(region: MlirRegion, reference: MlirBlock, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it before the (non-owned)\n reference block in the given region. The reference block must belong to the\n region. If the reference block is null, appends the block to the region."]
    pub fn mlirRegionInsertOwnedBlockBefore(region: MlirRegion, reference: MlirBlock, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Returns first region attached to the operation."]
    pub fn mlirOperationGetFirstRegion(op: MlirOperation) -> MlirRegion;
}
unsafe extern "C" {
    #[doc = " Returns the region immediately following the given region in its parent\n operation."]
    pub fn mlirRegionGetNextInOperation(region: MlirRegion) -> MlirRegion;
}
unsafe extern "C" {
    #[doc = " Moves the entire content of the source region to the target region."]
    pub fn mlirRegionTakeBody(target: MlirRegion, source: MlirRegion);
}
unsafe extern "C" {
    #[doc = " Creates a new empty block with the given argument types and transfers\n ownership to the caller."]
    pub fn mlirBlockCreate(nArgs: isize, args: *const MlirType, locs: *const MlirLocation) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Takes a block owned by the caller and destroys it."]
    pub fn mlirBlockDestroy(block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Detach a block from the owning region and assume ownership."]
    pub fn mlirBlockDetach(block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Checks whether two blocks handles point to the same block. This does not\n perform deep comparison."]
    pub fn mlirBlockEqual(block: MlirBlock, other: MlirBlock) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the closest surrounding operation that contains this block."]
    pub fn mlirBlockGetParentOperation(arg1: MlirBlock) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Returns the region that contains this block."]
    pub fn mlirBlockGetParentRegion(block: MlirBlock) -> MlirRegion;
}
unsafe extern "C" {
    #[doc = " Returns the block immediately following the given block in its parent\n region."]
    pub fn mlirBlockGetNextInRegion(block: MlirBlock) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Returns the first operation in the block."]
    pub fn mlirBlockGetFirstOperation(block: MlirBlock) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Returns the terminator operation in the block or null if no terminator."]
    pub fn mlirBlockGetTerminator(block: MlirBlock) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Takes an operation owned by the caller and appends it to the block."]
    pub fn mlirBlockAppendOwnedOperation(block: MlirBlock, operation: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it as `pos` to the block.\n This is an expensive operation that scans the block linearly, prefer\n insertBefore/After instead."]
    pub fn mlirBlockInsertOwnedOperation(block: MlirBlock, pos: isize, operation: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it after the (non-owned)\n reference operation in the given block. If the reference is null, prepends\n the operation. Otherwise, the reference must belong to the block."]
    pub fn mlirBlockInsertOwnedOperationAfter(block: MlirBlock, reference: MlirOperation, operation: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it before the (non-owned)\n reference operation in the given block. If the reference is null, appends\n the operation. Otherwise, the reference must belong to the block."]
    pub fn mlirBlockInsertOwnedOperationBefore(block: MlirBlock, reference: MlirOperation, operation: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Returns the number of arguments of the block."]
    pub fn mlirBlockGetNumArguments(block: MlirBlock) -> isize;
}
unsafe extern "C" {
    #[doc = " Appends an argument of the specified type to the block. Returns the newly\n added argument."]
    pub fn mlirBlockAddArgument(block: MlirBlock, type_: MlirType, loc: MlirLocation) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Erase the argument at 'index' and remove it from the argument list."]
    pub fn mlirBlockEraseArgument(block: MlirBlock, index: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Inserts an argument of the specified type at a specified index to the block.\n Returns the newly added argument."]
    pub fn mlirBlockInsertArgument(block: MlirBlock, pos: isize, type_: MlirType, loc: MlirLocation) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th argument of the block."]
    pub fn mlirBlockGetArgument(block: MlirBlock, pos: isize) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Prints a block by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirBlockPrint(block: MlirBlock, callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Returns the number of successor blocks of the block."]
    pub fn mlirBlockGetNumSuccessors(block: MlirBlock) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th successor of the block."]
    pub fn mlirBlockGetSuccessor(block: MlirBlock, pos: isize) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Returns the number of predecessor blocks of the block."]
    pub fn mlirBlockGetNumPredecessors(block: MlirBlock) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th predecessor of the block.\n\n WARNING: This getter is more expensive than the others here because\n the impl actually iterates the use-def chain (of block operands) anew for\n each indexed access."]
    pub fn mlirBlockGetPredecessor(block: MlirBlock, pos: isize) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Returns 1 if two values are equal, 0 otherwise."]
    pub fn mlirValueEqual(value1: MlirValue, value2: MlirValue) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns 1 if the value is a block argument, 0 otherwise."]
    pub fn mlirValueIsABlockArgument(value: MlirValue) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns 1 if the value is an operation result, 0 otherwise."]
    pub fn mlirValueIsAOpResult(value: MlirValue) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the block in which this value is defined as an argument. Asserts if\n the value is not a block argument."]
    pub fn mlirBlockArgumentGetOwner(value: MlirValue) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Returns the position of the value in the argument list of its block."]
    pub fn mlirBlockArgumentGetArgNumber(value: MlirValue) -> isize;
}
unsafe extern "C" {
    #[doc = " Sets the type of the block argument to the given type."]
    pub fn mlirBlockArgumentSetType(value: MlirValue, type_: MlirType);
}
unsafe extern "C" {
    #[doc = " Sets the location of the block argument to the given location."]
    pub fn mlirBlockArgumentSetLocation(value: MlirValue, loc: MlirLocation);
}
unsafe extern "C" {
    #[doc = " Returns an operation that produced this value as its result. Asserts if the\n value is not an op result."]
    pub fn mlirOpResultGetOwner(value: MlirValue) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Returns the position of the value in the list of results of the operation\n that produced it."]
    pub fn mlirOpResultGetResultNumber(value: MlirValue) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the type of the value."]
    pub fn mlirValueGetType(value: MlirValue) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Set the type of the value."]
    pub fn mlirValueSetType(value: MlirValue, type_: MlirType);
}
unsafe extern "C" {
    #[doc = " Prints the value to the standard error stream."]
    pub fn mlirValueDump(value: MlirValue);
}
unsafe extern "C" {
    #[doc = " Prints a value by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirValuePrint(value: MlirValue, callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Prints a value as an operand (i.e., the ValueID)."]
    pub fn mlirValuePrintAsOperand(
        value: MlirValue,
        state: MlirAsmState,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Returns an op operand representing the first use of the value, or a null op\n operand if there are no uses."]
    pub fn mlirValueGetFirstUse(value: MlirValue) -> MlirOpOperand;
}
unsafe extern "C" {
    #[doc = " Replace all uses of 'of' value with the 'with' value, updating anything in\n the IR that uses 'of' to use the other value instead.  When this returns\n there are zero uses of 'of'."]
    pub fn mlirValueReplaceAllUsesOfWith(of: MlirValue, with: MlirValue);
}
unsafe extern "C" {
    #[doc = " Replace all uses of 'of' value with 'with' value, updating anything in the\n IR that uses 'of' to use 'with' instead, except if the user is listed in\n 'exceptions'. The 'exceptions' parameter is an array of MlirOperation\n pointers with a length of 'numExceptions'."]
    pub fn mlirValueReplaceAllUsesExcept(
        of: MlirValue,
        with: MlirValue,
        numExceptions: isize,
        exceptions: *mut MlirOperation,
    );
}
unsafe extern "C" {
    #[doc = " Gets the location of the value."]
    pub fn mlirValueGetLocation(v: MlirValue) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Gets the context that a value was created with."]
    pub fn mlirValueGetContext(v: MlirValue) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Returns whether the op operand is null."]
    pub fn mlirOpOperandIsNull(opOperand: MlirOpOperand) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the value of an op operand."]
    pub fn mlirOpOperandGetValue(opOperand: MlirOpOperand) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Returns the owner operation of an op operand."]
    pub fn mlirOpOperandGetOwner(opOperand: MlirOpOperand) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Returns the operand number of an op operand."]
    pub fn mlirOpOperandGetOperandNumber(opOperand: MlirOpOperand) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Returns an op operand representing the next use of the value, or a null op\n operand if there is no next use."]
    pub fn mlirOpOperandGetNextUse(opOperand: MlirOpOperand) -> MlirOpOperand;
}
unsafe extern "C" {
    #[doc = " Parses a type. The type is owned by the context."]
    pub fn mlirTypeParseGet(context: MlirContext, type_: MlirStringRef) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Gets the context that a type was created with."]
    pub fn mlirTypeGetContext(type_: MlirType) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Gets the type ID of the type."]
    pub fn mlirTypeGetTypeID(type_: MlirType) -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Gets the dialect a type belongs to."]
    pub fn mlirTypeGetDialect(type_: MlirType) -> MlirDialect;
}
unsafe extern "C" {
    #[doc = " Checks if two types are equal."]
    pub fn mlirTypeEqual(t1: MlirType, t2: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints a location by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirTypePrint(type_: MlirType, callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Prints the type to the standard error stream."]
    pub fn mlirTypeDump(type_: MlirType);
}
unsafe extern "C" {
    #[doc = " Parses an attribute. The attribute is owned by the context."]
    pub fn mlirAttributeParseGet(context: MlirContext, attr: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Gets the context that an attribute was created with."]
    pub fn mlirAttributeGetContext(attribute: MlirAttribute) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Gets the type of this attribute."]
    pub fn mlirAttributeGetType(attribute: MlirAttribute) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Gets the type id of the attribute."]
    pub fn mlirAttributeGetTypeID(attribute: MlirAttribute) -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Gets the dialect of the attribute."]
    pub fn mlirAttributeGetDialect(attribute: MlirAttribute) -> MlirDialect;
}
unsafe extern "C" {
    #[doc = " Checks if two attributes are equal."]
    pub fn mlirAttributeEqual(a1: MlirAttribute, a2: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints an attribute by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirAttributePrint(attr: MlirAttribute, callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Prints the attribute to the standard error stream."]
    pub fn mlirAttributeDump(attr: MlirAttribute);
}
unsafe extern "C" {
    #[doc = " Associates an attribute with the name. Takes ownership of neither."]
    pub fn mlirNamedAttributeGet(name: MlirIdentifier, attr: MlirAttribute) -> MlirNamedAttribute;
}
unsafe extern "C" {
    #[doc = " Gets an identifier with the given string value."]
    pub fn mlirIdentifierGet(context: MlirContext, str_: MlirStringRef) -> MlirIdentifier;
}
unsafe extern "C" {
    #[doc = " Returns the context associated with this identifier"]
    pub fn mlirIdentifierGetContext(arg1: MlirIdentifier) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Checks whether two identifiers are the same."]
    pub fn mlirIdentifierEqual(ident: MlirIdentifier, other: MlirIdentifier) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the string value of the identifier."]
    pub fn mlirIdentifierStr(ident: MlirIdentifier) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the name of the attribute used to store symbol names compatible with\n symbol tables."]
    pub fn mlirSymbolTableGetSymbolAttributeName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the name of the attribute used to store symbol visibility."]
    pub fn mlirSymbolTableGetVisibilityAttributeName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a symbol table for the given operation. If the operation does not\n have the SymbolTable trait, returns a null symbol table."]
    pub fn mlirSymbolTableCreate(operation: MlirOperation) -> MlirSymbolTable;
}
unsafe extern "C" {
    #[doc = " Destroys the symbol table created with mlirSymbolTableCreate. This does not\n affect the operations in the table."]
    pub fn mlirSymbolTableDestroy(symbolTable: MlirSymbolTable);
}
unsafe extern "C" {
    #[doc = " Looks up a symbol with the given name in the given symbol table and returns\n the operation that corresponds to the symbol. If the symbol cannot be found,\n returns a null operation."]
    pub fn mlirSymbolTableLookup(symbolTable: MlirSymbolTable, name: MlirStringRef) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Inserts the given operation into the given symbol table. The operation must\n have the symbol trait. If the symbol table already has a symbol with the\n same name, renames the symbol being inserted to ensure name uniqueness. Note\n that this does not move the operation itself into the block of the symbol\n table operation, this should be done separately. Returns the name of the\n symbol after insertion."]
    pub fn mlirSymbolTableInsert(symbolTable: MlirSymbolTable, operation: MlirOperation) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Removes the given operation from the symbol table and erases it."]
    pub fn mlirSymbolTableErase(symbolTable: MlirSymbolTable, operation: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Attempt to replace all uses that are nested within the given operation\n of the given symbol 'oldSymbol' with the provided 'newSymbol'. This does\n not traverse into nested symbol tables. Will fail atomically if there are\n any unknown operations that may be potential symbol tables."]
    pub fn mlirSymbolTableReplaceAllSymbolUses(
        oldSymbol: MlirStringRef,
        newSymbol: MlirStringRef,
        from: MlirOperation,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Walks all symbol table operations nested within, and including, `op`. For\n each symbol table operation, the provided callback is invoked with the op\n and a boolean signifying if the symbols within that symbol table can be\n treated as if all uses within the IR are visible to the caller.\n `allSymUsesVisible` identifies whether all of the symbol uses of symbols\n within `op` are visible."]
    pub fn mlirSymbolTableWalkSymbolTables(
        from: MlirOperation,
        allSymUsesVisible: bool,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: MlirOperation, arg2: bool, userData: *mut ::std::os::raw::c_void),
        >,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGet(
        ctx: MlirContext,
        nUpdateWindowDims: isize,
        updateWindowDims: *const i64,
        nInsertedWindowDims: isize,
        insertedWindowDims: *const i64,
        nInputBatchingDims: isize,
        inputBatchingDims: *const i64,
        nScatterIndicesBatchingDims: isize,
        scatterIndicesBatchingDims: *const i64,
        nScatteredDimsToOperandDims: isize,
        scatteredDimsToOperandDims: *const i64,
        indexVectorDim: i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAScatterDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetUpdateWindowDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetUpdateWindowDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetInsertedWindowDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetInsertedWindowDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetInputBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetInputBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetScatterIndicesBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetScatterIndicesBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetScatteredDimsToOperandDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloScatterDimensionNumbersGetScatteredDimsToOperandDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloDimensionNumbersGetIndexVectorDim(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGet(
        ctx: MlirContext,
        nOffsetDims: isize,
        offsetDims: *const i64,
        nCollapsedSliceDims: isize,
        collapsedSliceDims: *const i64,
        nOperandBatchingDims: isize,
        operandBatchingDims: *const i64,
        nStartIndicesBatchingDims: isize,
        startIndicesBatchingDims: *const i64,
        nStartIndexMap: isize,
        startIndexMap: *const i64,
        indexVectorDim: i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAGatherDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetOffsetDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetOffsetDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetCollapsedSliceDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetCollapsedSliceDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetOperandBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetOperandBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetStartIndicesBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetStartIndicesBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetStartIndexMapSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetStartIndexMapElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloGatherDimensionNumbersGetIndexVectorDim(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGet(
        ctx: MlirContext,
        nLhsBatchingDimensions: isize,
        lhsBatchingDimensions: *const i64,
        nRhsBatchingDimensions: isize,
        rhsBatchingDimensions: *const i64,
        nLhsContractingDimensions: isize,
        lhsContractingDimensions: *const i64,
        nRhsContractingDimensions: isize,
        rhsContractingDimensions: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsADotDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetLhsBatchingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetLhsBatchingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetRhsBatchingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetRhsBatchingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetLhsContractingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetLhsContractingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetRhsContractingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloDotDimensionNumbersGetRhsContractingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGet(
        ctx: MlirContext,
        inputBatchDimension: i64,
        inputFeatureDimension: i64,
        nInputSpatialDimensions: isize,
        inputSpatialDimensions: *const i64,
        kernelInputFeatureDimension: i64,
        kernelOutputFeatureDimension: i64,
        nKernelSpatialDimensions: isize,
        kernelSpatialDimensions: *const i64,
        outputBatchDimension: i64,
        outputFeatureDimension: i64,
        nOutputSpatialDimensions: isize,
        outputSpatialDimensions: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAConvDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetInputBatchDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetInputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetInputSpatialDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetInputSpatialDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetKernelInputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetKernelOutputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetKernelSpatialDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetKernelSpatialDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetOutputBatchDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetOutputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetOutputSpatialDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloConvDimensionNumbersGetOutputSpatialDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloOutputOperandAliasGet(
        ctx: MlirContext,
        nOutputTupleIndices: isize,
        outputTupleIndices: *const i64,
        operandIndex: i64,
        nOperandTupleIndices: isize,
        operandTupleIndices: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAOutputOperandAlias(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloOutputOperandAliasGetOutputTupleIndicesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloOutputOperandAliasGetOutputTupleIndicesElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloOutputOperandAliasGetOperandIndex(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloOutputOperandAliasGetOperandTupleIndicesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloOutputOperandAliasGetOperandTupleIndicesElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloComparisonDirectionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAComparisonDirectionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloComparisonDirectionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloComparisonTypeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAComparisonTypeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloComparisonTypeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloDomainKindAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsADomainKindAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloDomainKindAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloPrecisionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAPrecisionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloPrecisionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloFftTypeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAFftTypeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloFftTypeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloDequantizeModeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsADequantizeModeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloDequantizeModeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloTransposeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsATransposeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloTransposeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloFusionKindAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsAFusionKindAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloFusionKindAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloRngDistributionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsARngDistributionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloRngDistributionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloRngAlgorithmAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsARngAlgorithmAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloRngAlgorithmAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirMhloChannelHandleGet(ctx: MlirContext, handle: i64, type_: i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsChannelHandle(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloChannelHandleGetHandle(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloChannelHandleGetType(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirMhloTypeExtensionsGet(ctx: MlirContext, nBounds: isize, bounds: *const i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirMhloAttributeIsTypeExtensions(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirMhloTypeExtensionsGetBoundsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirMhloTypeExtensionsGetBoundsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    #[doc = " Appends all upstream dialects and extensions to the dialect registry."]
    pub fn mlirRegisterAllDialects(registry: MlirDialectRegistry);
}
unsafe extern "C" {
    #[doc = " Register all translations to LLVM IR for dialects that can support it."]
    pub fn mlirRegisterAllLLVMTranslations(context: MlirContext);
}
unsafe extern "C" {
    #[doc = " Register all compiler passes of MLIR."]
    pub fn mlirRegisterAllPasses();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__chlo__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__mhlo__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Register all compiler passes of MHLO."]
    pub fn mlirRegisterAllMhloPasses();
}
unsafe extern "C" {
    pub fn mlirMhloTokenTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirMhloTypeIsAToken(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn chloComparisonDirectionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn chloAttributeIsAComparisonDirectionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn chloComparisonDirectionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn chloComparisonTypeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn chloAttributeIsAComparisonTypeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn chloComparisonTypeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGet(
        ctx: MlirContext,
        nLhsBatchingDimensions: isize,
        lhsBatchingDimensions: *const i64,
        nRhsBatchingDimensions: isize,
        rhsBatchingDimensions: *const i64,
        nLhsContractingDimensions: isize,
        lhsContractingDimensions: *const i64,
        nRhsContractingDimensions: isize,
        rhsContractingDimensions: *const i64,
        nLhsRaggedDimensions: isize,
        lhsRaggedDimensions: *const i64,
        nRhsGroupDimensions: isize,
        rhsGroupDimensions: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn chloAttributeIsARaggedDotDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetLhsBatchingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetLhsBatchingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetRhsBatchingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetRhsBatchingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetLhsContractingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetLhsContractingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetRhsContractingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetRhsContractingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetLhsRaggedDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetLhsRaggedDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetRhsGroupDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn chloRaggedDotDimensionNumbersGetRhsGroupDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn chloPrecisionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn chloAttributeIsAPrecisionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn chloPrecisionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__interpreter__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGet(
        ctx: MlirContext,
        nUpdateWindowDims: isize,
        updateWindowDims: *const i64,
        nInsertedWindowDims: isize,
        insertedWindowDims: *const i64,
        nInputBatchingDims: isize,
        inputBatchingDims: *const i64,
        nScatterIndicesBatchingDims: isize,
        scatterIndicesBatchingDims: *const i64,
        nScatteredDimsToOperandDims: isize,
        scatteredDimsToOperandDims: *const i64,
        indexVectorDim: i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAScatterDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetUpdateWindowDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetUpdateWindowDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetInsertedWindowDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetInsertedWindowDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetInputBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetInputBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetScatterIndicesBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetScatterIndicesBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetScatteredDimsToOperandDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloScatterDimensionNumbersGetScatteredDimsToOperandDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDimensionNumbersGetIndexVectorDim(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGet(
        ctx: MlirContext,
        nOffsetDims: isize,
        offsetDims: *const i64,
        nCollapsedSliceDims: isize,
        collapsedSliceDims: *const i64,
        nOperandBatchingDims: isize,
        operandBatchingDims: *const i64,
        nStartIndicesBatchingDims: isize,
        startIndicesBatchingDims: *const i64,
        nStartIndexMap: isize,
        startIndexMap: *const i64,
        indexVectorDim: i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAGatherDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetOffsetDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetOffsetDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetCollapsedSliceDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetCollapsedSliceDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetOperandBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetOperandBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetStartIndicesBatchingDimsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetStartIndicesBatchingDimsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetStartIndexMapSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetStartIndexMapElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloGatherDimensionNumbersGetIndexVectorDim(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGet(
        ctx: MlirContext,
        lhsPrecisionType: MlirType,
        rhsPrecisionType: MlirType,
        accumulationType: MlirType,
        lhsComponentCount: i64,
        rhsComponentCount: i64,
        numPrimitiveOperations: i64,
        allowImpreciseAccumulation: bool,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsADotAlgorithm(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetLhsPrecisionType(attr: MlirAttribute) -> MlirType;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetRhsPrecisionType(attr: MlirAttribute) -> MlirType;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetAccumulationType(attr: MlirAttribute) -> MlirType;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetLhsComponentCount(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetRhsComponentCount(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetNumPrimitiveOperations(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotAlgorithmGetAllowImpreciseAccumulation(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGet(
        ctx: MlirContext,
        nLhsBatchingDimensions: isize,
        lhsBatchingDimensions: *const i64,
        nRhsBatchingDimensions: isize,
        rhsBatchingDimensions: *const i64,
        nLhsContractingDimensions: isize,
        lhsContractingDimensions: *const i64,
        nRhsContractingDimensions: isize,
        rhsContractingDimensions: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsADotDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetLhsBatchingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetLhsBatchingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetRhsBatchingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetRhsBatchingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetLhsContractingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetLhsContractingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetRhsContractingDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloDotDimensionNumbersGetRhsContractingDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGet(
        ctx: MlirContext,
        inputBatchDimension: i64,
        inputFeatureDimension: i64,
        nInputSpatialDimensions: isize,
        inputSpatialDimensions: *const i64,
        kernelInputFeatureDimension: i64,
        kernelOutputFeatureDimension: i64,
        nKernelSpatialDimensions: isize,
        kernelSpatialDimensions: *const i64,
        outputBatchDimension: i64,
        outputFeatureDimension: i64,
        nOutputSpatialDimensions: isize,
        outputSpatialDimensions: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAConvDimensionNumbers(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetInputBatchDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetInputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetInputSpatialDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetInputSpatialDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetKernelInputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetKernelOutputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetKernelSpatialDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetKernelSpatialDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetOutputBatchDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetOutputFeatureDimension(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetOutputSpatialDimensionsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloConvDimensionNumbersGetOutputSpatialDimensionsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloOutputOperandAliasGet(
        ctx: MlirContext,
        nOutputTupleIndices: isize,
        outputTupleIndices: *const i64,
        operandIndex: i64,
        nOperandTupleIndices: isize,
        operandTupleIndices: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAOutputOperandAlias(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloOutputOperandAliasGetOutputTupleIndicesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloOutputOperandAliasGetOutputTupleIndicesElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloOutputOperandAliasGetOperandIndex(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloOutputOperandAliasGetOperandTupleIndicesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloOutputOperandAliasGetOperandTupleIndicesElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloComparisonDirectionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAComparisonDirectionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloComparisonDirectionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloComparisonTypeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAComparisonTypeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloComparisonTypeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloPrecisionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAPrecisionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloPrecisionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloFftTypeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAFftTypeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloFftTypeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloTransposeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsATransposeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloTransposeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloRngDistributionAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsARngDistributionAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloRngDistributionAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloRngAlgorithmAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsARngAlgorithmAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloRngAlgorithmAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloChannelHandleGet(ctx: MlirContext, handle: i64, type_: i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsChannelHandle(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloChannelHandleGetHandle(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloChannelHandleGetType(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloTypeExtensionsGet(ctx: MlirContext, nBounds: isize, bounds: *const i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsTypeExtensions(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloTypeExtensionsGetBoundsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn stablehloTypeExtensionsGetBoundsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyModeAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAResultAccuracyModeAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyModeAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyAttrGet(
        ctx: MlirContext,
        atol: f64,
        rtol: f64,
        ulps: i64,
        value: MlirStringRef,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn stablehloAttributeIsAResultAccuracyAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyAttrGetAtol(attr: MlirAttribute) -> f64;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyAttrGetRtol(attr: MlirAttribute) -> f64;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyAttrGetUlps(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn stablehloResultAccuracyAttrGetMode(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__stablehlo__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn stablehloGetApiVersion() -> ::std::os::raw::c_int;
}
pub const MlirStablehloCompatibilityRequirement_NONE: MlirStablehloCompatibilityRequirement = 0;
pub const MlirStablehloCompatibilityRequirement_WEEK_4: MlirStablehloCompatibilityRequirement = 1;
pub const MlirStablehloCompatibilityRequirement_WEEK_12: MlirStablehloCompatibilityRequirement = 2;
pub const MlirStablehloCompatibilityRequirement_MAX: MlirStablehloCompatibilityRequirement = 3;
pub type MlirStablehloCompatibilityRequirement = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn stablehloVersionFromCompatibilityRequirement(
        requirement: MlirStablehloCompatibilityRequirement,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn stablehloGetCurrentVersion(callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn stablehloGetMinimumVersion(callback: MlirStringCallback, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn stablehloGetSmallerVersion(
        version1: MlirStringRef,
        version2: MlirStringRef,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn stablehloSerializePortableArtifactFromStringRef(
        moduleStr: MlirStringRef,
        targetVersion: MlirStringRef,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn stablehloSerializePortableArtifactFromModule(
        moduleStr: MlirModule,
        targetVersion: MlirStringRef,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
        allowOtherDialects: bool,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn stablehloDeserializePortableArtifact(
        artifactStr: MlirStringRef,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn stablehloDeserializePortableArtifactNoError(artifactStr: MlirStringRef, ctx: MlirContext) -> MlirModule;
}
unsafe extern "C" {
    #[doc = " Register all compiler passes of StableHLO."]
    pub fn mlirRegisterAllStablehloPasses();
}
unsafe extern "C" {
    pub fn stablehloTokenTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn stablehloTypeIsAToken(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn stablehloEvalModule(
        module: MlirModule,
        nArgs: ::std::os::raw::c_int,
        args: *const MlirAttribute,
        probeInstrumentationDir: *const ::std::os::raw::c_char,
        errorCode: *mut ::std::os::raw::c_int,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__vhlo__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn sdyAttributeIsAMeshAxisAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyMeshAxisAttrGet(ctx: MlirContext, name: MlirStringRef, size: i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyMeshAxisAttrGetName(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn sdyMeshAxisAttrGetSize(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn sdyAttributeIsAMeshAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyMeshAttrGet(
        ctx: MlirContext,
        nAxes: isize,
        axes: *const MlirAttribute,
        nDeviceIds: isize,
        deviceIds: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyMeshAttrGetDeviceIdsSize(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn sdyMeshAttrGetDeviceIdsElem(attr: MlirAttribute, pos: i64) -> i64;
}
unsafe extern "C" {
    pub fn sdyMeshAttrGetAxesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyMeshAttrGetAxesElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyAttributeIsASubAxisInfoAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdySubAxisInfoAttrGet(ctx: MlirContext, preSize: i64, size: i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdySubAxisInfoAttrGetPreSize(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn sdySubAxisInfoAttrGetSize(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn sdyAttributeIsAnAxisRefAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyAxisRefAttrGet(ctx: MlirContext, name: MlirStringRef, subAxisInfo: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyAxisRefAttrGetName(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn sdyAxisRefAttrGetSubAxisInfo(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyAttributeIsADimensionShardingAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyDimensionShardingAttrGet(
        ctx: MlirContext,
        nAxes: isize,
        axes: *const MlirAttribute,
        isClosed: bool,
        priority: i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyDimensionShardingAttrGetAxesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyDimensionShardingAttrGetAxesElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyDimensionShardingAttrGetIsClosed(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyDimensionShardingAttrGetPriority(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn sdyAttributeIsATensorShardingAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGet(
        ctx: MlirContext,
        meshOrRef: MlirAttribute,
        nDimShardings: isize,
        dimShardings: *const MlirAttribute,
        nReplicatedAxes: isize,
        replicatedAxes: *const MlirAttribute,
        nUnreducedAxes: isize,
        unreducedAxes: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetMeshOrRef(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetDimShardingsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetDimShardingsElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetReplicatedAxesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetReplicatedAxesElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetUnreducedAxesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyTensorShardingAttrGetUnreducedAxesElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyAttributeIsATensorShardingPerValueAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyTensorShardingPerValueAttrGet(
        ctx: MlirContext,
        nShardings: isize,
        shardings: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyTensorShardingPerValueAttrGetShardingsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyTensorShardingPerValueAttrGetShardingsElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyAttributeIsADimMappingAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyDimMappingAttrGet(ctx: MlirContext, nFactorIndices: isize, factorIndices: *const i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyDimMappingAttrGetFactorIndicesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyDimMappingAttrGetFactorIndicesElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn sdyAttributeIsATensorMappingAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyTensorMappingAttrGet(ctx: MlirContext, nMappings: isize, mappings: *const MlirAttribute)
    -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyTensorMappingAttrGetRank(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyTensorMappingAttrGetDimMappingsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyTensorMappingAttrGetDimMappingsElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyAttributeIsAOpShardingRuleAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGet(
        ctx: MlirContext,
        nFactorSizes: isize,
        factorSizes: *const i64,
        nOperandMappings: isize,
        operandMappings: *const MlirAttribute,
        nResultMappings: isize,
        resultMappings: *const MlirAttribute,
        nReductionFactors: isize,
        reductionFactors: *const i64,
        nNeedReplicationFactors: isize,
        needReplicationFactors: *const i64,
        nPermutationFactors: isize,
        permutationFactors: *const i64,
        nBlockedPropagationFactors: isize,
        blockedPropagationFactors: *const i64,
        isCustomRule: bool,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetIsCustom(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetFactorSizesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetFactorSizesElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetOperandMappingsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetOperandMappingsElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetResultMappingsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetResultMappingsElem(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetReductionFactorsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetReductionFactorsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetNeedReplicationFactorsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetNeedReplicationFactorsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetPermutationFactorsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetPermutationFactorsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetBlockedPropagationFactorsSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyOpShardingRuleAttrGetBlockedPropagationFactorsElem(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn sdyAttributeIsAManualAxesAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn sdyManualAxesAttrGet(ctx: MlirContext, nAxes: isize, axes: *const MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn sdyManualAxesAttrGetAxesSize(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn sdyManualAxesAttrGetAxesElem(attr: MlirAttribute, pos: isize) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__sdy__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Register all compiler passes and pipelines of Shardy."]
    pub fn mlirRegisterAllSdyPassesAndPipelines();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAffineExpr {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirAffineExpr"][::std::mem::size_of::<MlirAffineExpr>() - 8usize];
    ["Alignment of MlirAffineExpr"][::std::mem::align_of::<MlirAffineExpr>() - 8usize];
    ["Offset of field: MlirAffineExpr::ptr"][::std::mem::offset_of!(MlirAffineExpr, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Gets the context that owns the affine expression."]
    pub fn mlirAffineExprGetContext(affineExpr: MlirAffineExpr) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the two affine expressions are equal."]
    pub fn mlirAffineExprEqual(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints an affine expression by sending chunks of the string representation\n and forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirAffineExprPrint(
        affineExpr: MlirAffineExpr,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Prints the affine expression to the standard error stream."]
    pub fn mlirAffineExprDump(affineExpr: MlirAffineExpr);
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is made out of only symbols and\n constants."]
    pub fn mlirAffineExprIsSymbolicOrConstant(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is a pure affine expression, i.e.\n mul, floordiv, ceildic, and mod is only allowed w.r.t constants."]
    pub fn mlirAffineExprIsPureAffine(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the greatest known integral divisor of this affine expression. The\n result is always positive."]
    pub fn mlirAffineExprGetLargestKnownDivisor(affineExpr: MlirAffineExpr) -> i64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is a multiple of 'factor'."]
    pub fn mlirAffineExprIsMultipleOf(affineExpr: MlirAffineExpr, factor: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression involves AffineDimExpr\n 'position'."]
    pub fn mlirAffineExprIsFunctionOfDim(affineExpr: MlirAffineExpr, position: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Composes the given map with the given expression."]
    pub fn mlirAffineExprCompose(affineExpr: MlirAffineExpr, affineMap: MlirAffineMap) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Replace dims[offset ... numDims)\n by dims[offset + shift ... shift + numDims)."]
    pub fn mlirAffineExprShiftDims(affineExpr: MlirAffineExpr, numDims: u32, shift: u32, offset: u32)
    -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Replace symbols[offset ... numSymbols)\n by symbols[offset + shift ... shift + numSymbols)."]
    pub fn mlirAffineExprShiftSymbols(
        affineExpr: MlirAffineExpr,
        numSymbols: u32,
        shift: u32,
        offset: u32,
    ) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Simplify an affine expression by flattening and some amount of simple\n analysis. This has complexity linear in the number of nodes in 'expr'.\n Returns the simplified expression, which is the same as the input expression\n if it can't be simplified. When `expr` is semi-affine, a simplified\n semi-affine expression is constructed in the sorted order of dimension and\n symbol positions."]
    pub fn mlirSimplifyAffineExpr(expr: MlirAffineExpr, numDims: u32, numSymbols: u32) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is a dimension expression."]
    pub fn mlirAffineExprIsADim(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine dimension expression with 'position' in the context."]
    pub fn mlirAffineDimExprGet(ctx: MlirContext, position: isize) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Returns the position of the given affine dimension expression."]
    pub fn mlirAffineDimExprGetPosition(affineExpr: MlirAffineExpr) -> isize;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is a symbol expression."]
    pub fn mlirAffineExprIsASymbol(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine symbol expression with 'position' in the context."]
    pub fn mlirAffineSymbolExprGet(ctx: MlirContext, position: isize) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Returns the position of the given affine symbol expression."]
    pub fn mlirAffineSymbolExprGetPosition(affineExpr: MlirAffineExpr) -> isize;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is a constant expression."]
    pub fn mlirAffineExprIsAConstant(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine constant expression with 'constant' in the context."]
    pub fn mlirAffineConstantExprGet(ctx: MlirContext, constant: i64) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Returns the value of the given affine constant expression."]
    pub fn mlirAffineConstantExprGetValue(affineExpr: MlirAffineExpr) -> i64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is an add expression."]
    pub fn mlirAffineExprIsAAdd(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine add expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineAddExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is an mul expression."]
    pub fn mlirAffineExprIsAMul(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine mul expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineMulExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is an mod expression."]
    pub fn mlirAffineExprIsAMod(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine mod expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineModExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is an floordiv expression."]
    pub fn mlirAffineExprIsAFloorDiv(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine floordiv expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineFloorDivExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is an ceildiv expression."]
    pub fn mlirAffineExprIsACeilDiv(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine ceildiv expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineCeilDivExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine expression is binary."]
    pub fn mlirAffineExprIsABinary(affineExpr: MlirAffineExpr) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the left hand side affine expression of the given affine binary\n operation expression."]
    pub fn mlirAffineBinaryOpExprGetLHS(affineExpr: MlirAffineExpr) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Returns the right hand side affine expression of the given affine binary\n operation expression."]
    pub fn mlirAffineBinaryOpExprGetRHS(affineExpr: MlirAffineExpr) -> MlirAffineExpr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAffineMap {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirAffineMap"][::std::mem::size_of::<MlirAffineMap>() - 8usize];
    ["Alignment of MlirAffineMap"][::std::mem::align_of::<MlirAffineMap>() - 8usize];
    ["Offset of field: MlirAffineMap::ptr"][::std::mem::offset_of!(MlirAffineMap, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Gets the context that the given affine map was created with"]
    pub fn mlirAffineMapGetContext(affineMap: MlirAffineMap) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Checks if two affine maps are equal."]
    pub fn mlirAffineMapEqual(a1: MlirAffineMap, a2: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints an affine map by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirAffineMapPrint(
        affineMap: MlirAffineMap,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Prints the affine map to the standard error stream."]
    pub fn mlirAffineMapDump(affineMap: MlirAffineMap);
}
unsafe extern "C" {
    #[doc = " Creates a zero result affine map with no dimensions or symbols in the\n context. The affine map is owned by the context."]
    pub fn mlirAffineMapEmptyGet(ctx: MlirContext) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Creates a zero result affine map of the given dimensions and symbols in the\n context. The affine map is owned by the context."]
    pub fn mlirAffineMapZeroResultGet(ctx: MlirContext, dimCount: isize, symbolCount: isize) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Creates an affine map with results defined by the given list of affine\n expressions. The map resulting map also has the requested number of input\n dimensions and symbols, regardless of them being used in the results."]
    pub fn mlirAffineMapGet(
        ctx: MlirContext,
        dimCount: isize,
        symbolCount: isize,
        nAffineExprs: isize,
        affineExprs: *mut MlirAffineExpr,
    ) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Creates a single constant result affine map in the context. The affine map\n is owned by the context."]
    pub fn mlirAffineMapConstantGet(ctx: MlirContext, val: i64) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Creates an affine map with 'numDims' identity in the context. The affine map\n is owned by the context."]
    pub fn mlirAffineMapMultiDimIdentityGet(ctx: MlirContext, numDims: isize) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Creates an identity affine map on the most minor dimensions in the context.\n The affine map is owned by the context. The function asserts that the number\n of dimensions is greater or equal to the number of results."]
    pub fn mlirAffineMapMinorIdentityGet(ctx: MlirContext, dims: isize, results: isize) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Creates an affine map with a permutation expression and its size in the\n context. The permutation expression is a non-empty vector of integers.\n The elements of the permutation vector must be continuous from 0 and cannot\n be repeated (i.e. `[1,2,0]` is a valid permutation. `[2,0]` or `[1,1,2]` is\n an invalid permutation.) The affine map is owned by the context."]
    pub fn mlirAffineMapPermutationGet(
        ctx: MlirContext,
        size: isize,
        permutation: *mut ::std::os::raw::c_uint,
    ) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine map is an identity affine map. The function\n asserts that the number of dimensions is greater or equal to the number of\n results."]
    pub fn mlirAffineMapIsIdentity(affineMap: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine map is a minor identity affine map."]
    pub fn mlirAffineMapIsMinorIdentity(affineMap: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine map is an empty affine map."]
    pub fn mlirAffineMapIsEmpty(affineMap: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine map is a single result constant affine\n map."]
    pub fn mlirAffineMapIsSingleConstant(affineMap: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the constant result of the given affine map. The function asserts\n that the map has a single constant result."]
    pub fn mlirAffineMapGetSingleConstantResult(affineMap: MlirAffineMap) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the number of dimensions of the given affine map."]
    pub fn mlirAffineMapGetNumDims(affineMap: MlirAffineMap) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of symbols of the given affine map."]
    pub fn mlirAffineMapGetNumSymbols(affineMap: MlirAffineMap) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of results of the given affine map."]
    pub fn mlirAffineMapGetNumResults(affineMap: MlirAffineMap) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the result at the given position."]
    pub fn mlirAffineMapGetResult(affineMap: MlirAffineMap, pos: isize) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Returns the number of inputs (dimensions + symbols) of the given affine\n map."]
    pub fn mlirAffineMapGetNumInputs(affineMap: MlirAffineMap) -> isize;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine map represents a subset of a symbol-less\n permutation map."]
    pub fn mlirAffineMapIsProjectedPermutation(affineMap: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given affine map represents a symbol-less permutation\n map."]
    pub fn mlirAffineMapIsPermutation(affineMap: MlirAffineMap) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the affine map consisting of the `resultPos` subset."]
    pub fn mlirAffineMapGetSubMap(affineMap: MlirAffineMap, size: isize, resultPos: *mut isize) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the affine map consisting of the most major `numResults` results.\n Returns the null AffineMap if the `numResults` is equal to zero.\n Returns the `affineMap` if `numResults` is greater or equals to number of\n results of the given affine map."]
    pub fn mlirAffineMapGetMajorSubMap(affineMap: MlirAffineMap, numResults: isize) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the affine map consisting of the most minor `numResults` results.\n Returns the null AffineMap if the `numResults` is equal to zero.\n Returns the `affineMap` if `numResults` is greater or equals to number of\n results of the given affine map."]
    pub fn mlirAffineMapGetMinorSubMap(affineMap: MlirAffineMap, numResults: isize) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Apply AffineExpr::replace(`map`) to each of the results and return a new\n new AffineMap with the new results and the specified number of dims and\n symbols."]
    pub fn mlirAffineMapReplace(
        affineMap: MlirAffineMap,
        expression: MlirAffineExpr,
        replacement: MlirAffineExpr,
        numResultDims: isize,
        numResultSyms: isize,
    ) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the simplified affine map resulting from dropping the symbols that\n do not appear in any of the individual maps in `affineMaps`.\n Asserts that all maps in `affineMaps` are normalized to the same number of\n dims and symbols.\n Takes a callback `populateResult` to fill the `res` container with value\n `m` at entry `idx`. This allows returning without worrying about ownership\n considerations."]
    pub fn mlirAffineMapCompressUnusedSymbols(
        affineMaps: *mut MlirAffineMap,
        size: isize,
        result: *mut ::std::os::raw::c_void,
        populateResult: ::std::option::Option<
            unsafe extern "C" fn(res: *mut ::std::os::raw::c_void, idx: isize, m: MlirAffineMap),
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirIntegerSet {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirIntegerSet"][::std::mem::size_of::<MlirIntegerSet>() - 8usize];
    ["Alignment of MlirIntegerSet"][::std::mem::align_of::<MlirIntegerSet>() - 8usize];
    ["Offset of field: MlirIntegerSet::ptr"][::std::mem::offset_of!(MlirIntegerSet, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Gets the context in which the given integer set lives."]
    pub fn mlirIntegerSetGetContext(set: MlirIntegerSet) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Checks if two integer set objects are equal. This is a \"shallow\" comparison\n of two objects. Only the sets with some small number of constraints are\n uniqued and compare equal here. Set objects that represent the same integer\n set with different constraints may be considered non-equal by this check.\n Set difference followed by an (expensive) emptiness check should be used to\n check equivalence of the underlying integer sets."]
    pub fn mlirIntegerSetEqual(s1: MlirIntegerSet, s2: MlirIntegerSet) -> bool;
}
unsafe extern "C" {
    #[doc = " Prints an integer set by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirIntegerSetPrint(
        set: MlirIntegerSet,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Prints an integer set to the standard error stream."]
    pub fn mlirIntegerSetDump(set: MlirIntegerSet);
}
unsafe extern "C" {
    #[doc = " Gets or creates a new canonically empty integer set with the give number of\n dimensions and symbols in the given context."]
    pub fn mlirIntegerSetEmptyGet(context: MlirContext, numDims: isize, numSymbols: isize) -> MlirIntegerSet;
}
unsafe extern "C" {
    #[doc = " Gets or creates a new integer set in the given context. The set is defined\n by a list of affine constraints, with the given number of input dimensions\n and symbols, which are treated as either equalities (eqFlags is 1) or\n inequalities (eqFlags is 0). Both `constraints` and `eqFlags` are expected\n to point to at least `numConstraint` consecutive values."]
    pub fn mlirIntegerSetGet(
        context: MlirContext,
        numDims: isize,
        numSymbols: isize,
        numConstraints: isize,
        constraints: *const MlirAffineExpr,
        eqFlags: *const bool,
    ) -> MlirIntegerSet;
}
unsafe extern "C" {
    #[doc = " Gets or creates a new integer set in which the values and dimensions of the\n given set are replaced with the given affine expressions. `dimReplacements`\n and `symbolReplacements` are expected to point to at least as many\n consecutive expressions as the given set has dimensions and symbols,\n respectively. The new set will have `numResultDims` and `numResultSymbols`\n dimensions and symbols, respectively."]
    pub fn mlirIntegerSetReplaceGet(
        set: MlirIntegerSet,
        dimReplacements: *const MlirAffineExpr,
        symbolReplacements: *const MlirAffineExpr,
        numResultDims: isize,
        numResultSymbols: isize,
    ) -> MlirIntegerSet;
}
unsafe extern "C" {
    #[doc = " Checks whether the given set is a canonical empty set, e.g., the set\n returned by mlirIntegerSetEmptyGet."]
    pub fn mlirIntegerSetIsCanonicalEmpty(set: MlirIntegerSet) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of dimensions in the given set."]
    pub fn mlirIntegerSetGetNumDims(set: MlirIntegerSet) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of symbols in the given set."]
    pub fn mlirIntegerSetGetNumSymbols(set: MlirIntegerSet) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of inputs (dimensions + symbols) in the given set."]
    pub fn mlirIntegerSetGetNumInputs(set: MlirIntegerSet) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of constraints (equalities + inequalities) in the given\n set."]
    pub fn mlirIntegerSetGetNumConstraints(set: MlirIntegerSet) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of equalities in the given set."]
    pub fn mlirIntegerSetGetNumEqualities(set: MlirIntegerSet) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of inequalities in the given set."]
    pub fn mlirIntegerSetGetNumInequalities(set: MlirIntegerSet) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th constraint of the set."]
    pub fn mlirIntegerSetGetConstraint(set: MlirIntegerSet, pos: isize) -> MlirAffineExpr;
}
unsafe extern "C" {
    #[doc = " Returns `true` of the `pos`-th constraint of the set is an equality\n constraint, `false` otherwise."]
    pub fn mlirIntegerSetIsConstraintEq(set: MlirIntegerSet, pos: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns an empty attribute."]
    pub fn mlirAttributeGetNull() -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirAttributeIsALocation(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is an affine map attribute."]
    pub fn mlirAttributeIsAAffineMap(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an affine map attribute wrapping the given map. The attribute\n belongs to the same context as the affine map."]
    pub fn mlirAffineMapAttrGet(map: MlirAffineMap) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirAffineMapAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the affine map wrapped in the given affine map attribute."]
    pub fn mlirAffineMapAttrGetValue(attr: MlirAttribute) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an AffineMap attribute."]
    pub fn mlirAffineMapAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is an array attribute."]
    pub fn mlirAttributeIsAArray(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an array element containing the given list of elements in the given\n context."]
    pub fn mlirArrayAttrGet(ctx: MlirContext, numElements: isize, elements: *const MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirArrayAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements stored in the given array attribute."]
    pub fn mlirArrayAttrGetNumElements(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns pos-th element stored in the given array attribute."]
    pub fn mlirArrayAttrGetElement(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Array attribute."]
    pub fn mlirArrayAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a dictionary attribute."]
    pub fn mlirAttributeIsADictionary(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a dictionary attribute containing the given list of elements in the\n provided context."]
    pub fn mlirDictionaryAttrGet(
        ctx: MlirContext,
        numElements: isize,
        elements: *const MlirNamedAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDictionaryAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of attributes contained in a dictionary attribute."]
    pub fn mlirDictionaryAttrGetNumElements(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns pos-th element of the given dictionary attribute."]
    pub fn mlirDictionaryAttrGetElement(attr: MlirAttribute, pos: isize) -> MlirNamedAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the dictionary attribute element with the given name or NULL if the\n given name does not exist in the dictionary."]
    pub fn mlirDictionaryAttrGetElementByName(attr: MlirAttribute, name: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a Dictionary attribute."]
    pub fn mlirDictionaryAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a floating point attribute."]
    pub fn mlirAttributeIsAFloat(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirFloatAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a floating point attribute in the given context with the given\n double value and double-precision FP semantics."]
    pub fn mlirFloatAttrDoubleGet(ctx: MlirContext, type_: MlirType, value: f64) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirFloatAttrDoubleGet\", but if the type is not valid for a\n construction of a FloatAttr, returns a null MlirAttribute."]
    pub fn mlirFloatAttrDoubleGetChecked(loc: MlirLocation, type_: MlirType, value: f64) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the value stored in the given floating point attribute, interpreting\n the value as double."]
    pub fn mlirFloatAttrGetValueDouble(attr: MlirAttribute) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a Float attribute."]
    pub fn mlirFloatAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is an integer attribute."]
    pub fn mlirAttributeIsAInteger(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an integer attribute of the given type with the given integer\n value."]
    pub fn mlirIntegerAttrGet(type_: MlirType, value: i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirIntegerAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the value stored in the given integer attribute, assuming the value\n is of signless type and fits into a signed 64-bit integer."]
    pub fn mlirIntegerAttrGetValueInt(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the value stored in the given integer attribute, assuming the value\n is of signed type and fits into a signed 64-bit integer."]
    pub fn mlirIntegerAttrGetValueSInt(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the value stored in the given integer attribute, assuming the value\n is of unsigned type and fits into an unsigned 64-bit integer."]
    pub fn mlirIntegerAttrGetValueUInt(attr: MlirAttribute) -> u64;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Integer attribute."]
    pub fn mlirIntegerAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a bool attribute."]
    pub fn mlirAttributeIsABool(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a bool attribute in the given context with the given value."]
    pub fn mlirBoolAttrGet(ctx: MlirContext, value: ::std::os::raw::c_int) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the value stored in the given bool attribute."]
    pub fn mlirBoolAttrGetValue(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is an integer set attribute."]
    pub fn mlirAttributeIsAIntegerSet(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an integer set attribute wrapping the given set. The attribute\n belongs to the same context as the integer set."]
    pub fn mlirIntegerSetAttrGet(set: MlirIntegerSet) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirIntegerSetAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the integer set wrapped in the given integer set attribute."]
    pub fn mlirIntegerSetAttrGetValue(attr: MlirAttribute) -> MlirIntegerSet;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an IntegerSet attribute."]
    pub fn mlirIntegerSetAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is an opaque attribute."]
    pub fn mlirAttributeIsAOpaque(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an opaque attribute in the given context associated with the dialect\n identified by its namespace. The attribute contains opaque byte data of the\n specified length (data need not be null-terminated)."]
    pub fn mlirOpaqueAttrGet(
        ctx: MlirContext,
        dialectNamespace: MlirStringRef,
        dataLength: isize,
        data: *const ::std::os::raw::c_char,
        type_: MlirType,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirOpaqueAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the namespace of the dialect with which the given opaque attribute\n is associated. The namespace string is owned by the context."]
    pub fn mlirOpaqueAttrGetDialectNamespace(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the raw data as a string reference. The data remains live as long as\n the context in which the attribute lives."]
    pub fn mlirOpaqueAttrGetData(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Opaque attribute."]
    pub fn mlirOpaqueAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a string attribute."]
    pub fn mlirAttributeIsAString(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a string attribute in the given context containing the given string."]
    pub fn mlirStringAttrGet(ctx: MlirContext, str_: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirStringAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a string attribute in the given context containing the given string.\n Additionally, the attribute has the given type."]
    pub fn mlirStringAttrTypedGet(type_: MlirType, str_: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the attribute values as a string reference. The data remains live as\n long as the context in which the attribute lives."]
    pub fn mlirStringAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a String attribute."]
    pub fn mlirStringAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a symbol reference attribute."]
    pub fn mlirAttributeIsASymbolRef(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a symbol reference attribute in the given context referencing a\n symbol identified by the given string inside a list of nested references.\n Each of the references in the list must not be nested."]
    pub fn mlirSymbolRefAttrGet(
        ctx: MlirContext,
        symbol: MlirStringRef,
        numReferences: isize,
        references: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirSymbolRefAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the string reference to the root referenced symbol. The data remains\n live as long as the context in which the attribute lives."]
    pub fn mlirSymbolRefAttrGetRootReference(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the string reference to the leaf referenced symbol. The data remains\n live as long as the context in which the attribute lives."]
    pub fn mlirSymbolRefAttrGetLeafReference(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of references nested in the given symbol reference\n attribute."]
    pub fn mlirSymbolRefAttrGetNumNestedReferences(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns pos-th reference nested in the given symbol reference attribute."]
    pub fn mlirSymbolRefAttrGetNestedReference(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an SymbolRef attribute."]
    pub fn mlirSymbolRefAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates a DisctinctAttr with the referenced attribute."]
    pub fn mlirDisctinctAttrCreate(referencedAttr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a flat symbol reference attribute."]
    pub fn mlirAttributeIsAFlatSymbolRef(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a flat symbol reference attribute in the given context referencing a\n symbol identified by the given string."]
    pub fn mlirFlatSymbolRefAttrGet(ctx: MlirContext, symbol: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirFlatSymbolRefAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the referenced symbol as a string reference. The data remains live\n as long as the context in which the attribute lives."]
    pub fn mlirFlatSymbolRefAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a type attribute."]
    pub fn mlirAttributeIsAType(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a type attribute wrapping the given type in the same context as the\n type."]
    pub fn mlirTypeAttrGet(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the type stored in the given type attribute."]
    pub fn mlirTypeAttrGetValue(attr: MlirAttribute) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a Type attribute."]
    pub fn mlirTypeAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a unit attribute."]
    pub fn mlirAttributeIsAUnit(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a unit attribute in the given context."]
    pub fn mlirUnitAttrGet(ctx: MlirContext) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnitAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a Unit attribute."]
    pub fn mlirUnitAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is an elements attribute."]
    pub fn mlirAttributeIsAElements(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the element at the given rank-dimensional index."]
    pub fn mlirElementsAttrGetValue(attr: MlirAttribute, rank: isize, idxs: *mut u64) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Checks whether the given rank-dimensional index is valid in the given\n elements attribute."]
    pub fn mlirElementsAttrIsValidIndex(attr: MlirAttribute, rank: isize, idxs: *mut u64) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the total number of elements in the given elements attribute. In order\n to iterate over the attribute, obtain its type, which must be a statically\n shaped type and use its sizes to build a multi-dimensional index."]
    pub fn mlirElementsAttrGetNumElements(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirDenseArrayAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a dense array attribute."]
    pub fn mlirAttributeIsADenseBoolArray(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseI8Array(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseI16Array(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseI32Array(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseI64Array(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseF32Array(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseF64Array(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Create a dense array attribute with the given elements."]
    pub fn mlirDenseBoolArrayGet(ctx: MlirContext, size: isize, values: *const ::std::os::raw::c_int) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseI8ArrayGet(ctx: MlirContext, size: isize, values: *const i8) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseI16ArrayGet(ctx: MlirContext, size: isize, values: *const i16) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseI32ArrayGet(ctx: MlirContext, size: isize, values: *const i32) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseI64ArrayGet(ctx: MlirContext, size: isize, values: *const i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseF32ArrayGet(ctx: MlirContext, size: isize, values: *const f32) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseF64ArrayGet(ctx: MlirContext, size: isize, values: *const f64) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Get the size of a dense array."]
    pub fn mlirDenseArrayGetNumElements(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    #[doc = " Get an element of a dense array."]
    pub fn mlirDenseBoolArrayGetElement(attr: MlirAttribute, pos: isize) -> bool;
}
unsafe extern "C" {
    pub fn mlirDenseI8ArrayGetElement(attr: MlirAttribute, pos: isize) -> i8;
}
unsafe extern "C" {
    pub fn mlirDenseI16ArrayGetElement(attr: MlirAttribute, pos: isize) -> i16;
}
unsafe extern "C" {
    pub fn mlirDenseI32ArrayGetElement(attr: MlirAttribute, pos: isize) -> i32;
}
unsafe extern "C" {
    pub fn mlirDenseI64ArrayGetElement(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirDenseF32ArrayGetElement(attr: MlirAttribute, pos: isize) -> f32;
}
unsafe extern "C" {
    pub fn mlirDenseF64ArrayGetElement(attr: MlirAttribute, pos: isize) -> f64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a dense elements attribute."]
    pub fn mlirAttributeIsADenseElements(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseIntElements(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseFPElements(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an DenseIntOrFPElements attribute."]
    pub fn mlirDenseIntOrFPElementsAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates a dense elements attribute with the given Shaped type and elements\n in the same context as the type."]
    pub fn mlirDenseElementsAttrGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a dense elements attribute with the given Shaped type and elements\n populated from a packed, row-major opaque buffer of contents.\n\n The format of the raw buffer is a densely packed array of values that\n can be bitcast to the storage format of the element type specified.\n Types that are not byte aligned will be:\n   - For bitwidth > 1: Rounded up to the next byte.\n   - For bitwidth = 1: Packed into 8bit bytes with bits corresponding to\n     the linear order of the shape type from MSB to LSB, padded to on the\n     right.\n\n A raw buffer of a single element (or for 1-bit, a byte of value 0 or 255)\n will be interpreted as a splat. User code should be prepared for additional,\n conformant patterns to be identified as splats in the future."]
    pub fn mlirDenseElementsAttrRawBufferGet(
        shapedType: MlirType,
        rawBufferSize: usize,
        rawBuffer: *const ::std::os::raw::c_void,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a dense elements attribute with the given Shaped type containing a\n single replicated element (splat)."]
    pub fn mlirDenseElementsAttrSplatGet(shapedType: MlirType, element: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrBoolSplatGet(shapedType: MlirType, element: bool) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt8SplatGet(shapedType: MlirType, element: u8) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt8SplatGet(shapedType: MlirType, element: i8) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt32SplatGet(shapedType: MlirType, element: u32) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt32SplatGet(shapedType: MlirType, element: i32) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt64SplatGet(shapedType: MlirType, element: u64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt64SplatGet(shapedType: MlirType, element: i64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrFloatSplatGet(shapedType: MlirType, element: f32) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrDoubleSplatGet(shapedType: MlirType, element: f64) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a dense elements attribute with the given shaped type from elements\n of a specific type. Expects the element type of the shaped type to match the\n data element type."]
    pub fn mlirDenseElementsAttrBoolGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const ::std::os::raw::c_int,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt8Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u8,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt8Get(shapedType: MlirType, numElements: isize, elements: *const i8)
    -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt16Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u16,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt16Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const i16,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt32Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u32,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt32Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const i32,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrUInt64Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrInt64Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrFloatGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const f32,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrDoubleGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const f64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrBFloat16Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u16,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrFloat16Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u16,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a dense elements attribute with the given shaped type from string\n elements."]
    pub fn mlirDenseElementsAttrStringGet(
        shapedType: MlirType,
        numElements: isize,
        strs: *mut MlirStringRef,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a dense elements attribute that has the same data as the given dense\n elements attribute and a different shaped type. The new type must have the\n same total number of elements."]
    pub fn mlirDenseElementsAttrReshapeGet(attr: MlirAttribute, shapedType: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Checks whether the given dense elements attribute contains a single\n replicated value (splat)."]
    pub fn mlirDenseElementsAttrIsSplat(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the single replicated value (splat) of a specific type contained by\n the given dense elements attribute."]
    pub fn mlirDenseElementsAttrGetSplatValue(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetBoolSplatValue(attr: MlirAttribute) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt8SplatValue(attr: MlirAttribute) -> i8;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt8SplatValue(attr: MlirAttribute) -> u8;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt32SplatValue(attr: MlirAttribute) -> i32;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt32SplatValue(attr: MlirAttribute) -> u32;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt64SplatValue(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt64SplatValue(attr: MlirAttribute) -> u64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetFloatSplatValue(attr: MlirAttribute) -> f32;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetDoubleSplatValue(attr: MlirAttribute) -> f64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetStringSplatValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the pos-th value (flat contiguous indexing) of a specific type\n contained by the given dense elements attribute."]
    pub fn mlirDenseElementsAttrGetBoolValue(attr: MlirAttribute, pos: isize) -> bool;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt8Value(attr: MlirAttribute, pos: isize) -> i8;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt8Value(attr: MlirAttribute, pos: isize) -> u8;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt16Value(attr: MlirAttribute, pos: isize) -> i16;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt16Value(attr: MlirAttribute, pos: isize) -> u16;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt32Value(attr: MlirAttribute, pos: isize) -> i32;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt32Value(attr: MlirAttribute, pos: isize) -> u32;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetInt64Value(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetUInt64Value(attr: MlirAttribute, pos: isize) -> u64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetIndexValue(attr: MlirAttribute, pos: isize) -> u64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetFloatValue(attr: MlirAttribute, pos: isize) -> f32;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetDoubleValue(attr: MlirAttribute, pos: isize) -> f64;
}
unsafe extern "C" {
    pub fn mlirDenseElementsAttrGetStringValue(attr: MlirAttribute, pos: isize) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the raw data of the given dense elements attribute."]
    pub fn mlirDenseElementsAttrGetRawData(attr: MlirAttribute) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mlirAttributeIsADenseResourceElements(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Unlike the typed accessors below, constructs the attribute with a raw\n data buffer and no type/alignment checking. Use a more strongly typed\n accessor if possible. If dataIsMutable is false, then an immutable\n AsmResourceBlob will be created and that passed data contents will be\n treated as const.\n If the deleter is non NULL, then it will be called when the data buffer\n can no longer be accessed (passing userData to it)."]
    pub fn mlirUnmanagedDenseResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        data: *mut ::std::os::raw::c_void,
        dataLength: usize,
        dataAlignment: usize,
        dataIsMutable: bool,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                userData: *mut ::std::os::raw::c_void,
                data: *const ::std::os::raw::c_void,
                size: usize,
                align: usize,
            ),
        >,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirDenseResourceElementsAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseBoolResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const ::std::os::raw::c_int,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseUInt8ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const u8,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseInt8ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const i8,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseUInt16ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const u16,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseInt16ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const i16,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseUInt32ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const u32,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseInt32ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const i32,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseUInt64ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const u64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseInt64ResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseFloatResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const f32,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirUnmanagedDenseDoubleResourceElementsAttrGet(
        shapedType: MlirType,
        name: MlirStringRef,
        numElements: isize,
        elements: *const f64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the pos-th value (flat contiguous indexing) of a specific type\n contained by the given dense resource elements attribute."]
    pub fn mlirDenseBoolResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> bool;
}
unsafe extern "C" {
    pub fn mlirDenseInt8ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> i8;
}
unsafe extern "C" {
    pub fn mlirDenseUInt8ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> u8;
}
unsafe extern "C" {
    pub fn mlirDenseInt16ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> i16;
}
unsafe extern "C" {
    pub fn mlirDenseUInt16ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> u16;
}
unsafe extern "C" {
    pub fn mlirDenseInt32ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> i32;
}
unsafe extern "C" {
    pub fn mlirDenseUInt32ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> u32;
}
unsafe extern "C" {
    pub fn mlirDenseInt64ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    pub fn mlirDenseUInt64ResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> u64;
}
unsafe extern "C" {
    pub fn mlirDenseFloatResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> f32;
}
unsafe extern "C" {
    pub fn mlirDenseDoubleResourceElementsAttrGetValue(attr: MlirAttribute, pos: isize) -> f64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a sparse elements attribute."]
    pub fn mlirAttributeIsASparseElements(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a sparse elements attribute of the given shape from a list of\n indices and a list of associated values. Both lists are expected to be dense\n elements attributes with the same number of elements. The list of indices is\n expected to contain 64-bit integers. The attribute is created in the same\n context as the type."]
    pub fn mlirSparseElementsAttribute(
        shapedType: MlirType,
        denseIndices: MlirAttribute,
        denseValues: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the dense elements attribute containing 64-bit integer indices of\n non-null elements in the given sparse elements attribute."]
    pub fn mlirSparseElementsAttrGetIndices(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the dense elements attribute containing the non-null elements in the\n given sparse elements attribute."]
    pub fn mlirSparseElementsAttrGetValues(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a SparseElements attribute."]
    pub fn mlirSparseElementsAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirAttributeIsAStridedLayout(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirStridedLayoutAttrGet(
        ctx: MlirContext,
        offset: i64,
        numStrides: isize,
        strides: *const i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirStridedLayoutAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirStridedLayoutAttrGetOffset(attr: MlirAttribute) -> i64;
}
unsafe extern "C" {
    pub fn mlirStridedLayoutAttrGetNumStrides(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    pub fn mlirStridedLayoutAttrGetStride(attr: MlirAttribute, pos: isize) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a StridedLayout attribute."]
    pub fn mlirStridedLayoutAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Integer type."]
    pub fn mlirIntegerTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an integer type."]
    pub fn mlirTypeIsAInteger(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a signless integer type of the given bitwidth in the context. The\n type is owned by the context."]
    pub fn mlirIntegerTypeGet(ctx: MlirContext, bitwidth: ::std::os::raw::c_uint) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirIntegerTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a signed integer type of the given bitwidth in the context. The type\n is owned by the context."]
    pub fn mlirIntegerTypeSignedGet(ctx: MlirContext, bitwidth: ::std::os::raw::c_uint) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates an unsigned integer type of the given bitwidth in the context. The\n type is owned by the context."]
    pub fn mlirIntegerTypeUnsignedGet(ctx: MlirContext, bitwidth: ::std::os::raw::c_uint) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the bitwidth of an integer type."]
    pub fn mlirIntegerTypeGetWidth(type_: MlirType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Checks whether the given integer type is signless."]
    pub fn mlirIntegerTypeIsSignless(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given integer type is signed."]
    pub fn mlirIntegerTypeIsSigned(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given integer type is unsigned."]
    pub fn mlirIntegerTypeIsUnsigned(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Index type."]
    pub fn mlirIndexTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an index type."]
    pub fn mlirTypeIsAIndex(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an index type in the given context. The type is owned by the\n context."]
    pub fn mlirIndexTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirIndexTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a floating-point type."]
    pub fn mlirTypeIsAFloat(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the bitwidth of a floating-point type."]
    pub fn mlirFloatTypeGetWidth(type_: MlirType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float4E2M1FN type."]
    pub fn mlirFloat4E2M1FNTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f4E2M1FN type."]
    pub fn mlirTypeIsAFloat4E2M1FN(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f4E2M1FN type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat4E2M1FNTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat4E2M1FNTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float6E2M3FN type."]
    pub fn mlirFloat6E2M3FNTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f6E2M3FN type."]
    pub fn mlirTypeIsAFloat6E2M3FN(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f6E2M3FN type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat6E2M3FNTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat6E2M3FNTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float6E3M2FN type."]
    pub fn mlirFloat6E3M2FNTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f6E3M2FN type."]
    pub fn mlirTypeIsAFloat6E3M2FN(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f6E3M2FN type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat6E3M2FNTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat6E3M2FNTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E5M2 type."]
    pub fn mlirFloat8E5M2TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E5M2 type."]
    pub fn mlirTypeIsAFloat8E5M2(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E5M2 type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E5M2TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E5M2TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E4M3 type."]
    pub fn mlirFloat8E4M3TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E4M3 type."]
    pub fn mlirTypeIsAFloat8E4M3(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E4M3 type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E4M3TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E4M3TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E4M3FN type."]
    pub fn mlirFloat8E4M3FNTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E4M3FN type."]
    pub fn mlirTypeIsAFloat8E4M3FN(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E4M3FN type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E4M3FNTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E4M3FNTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E5M2FNUZ type."]
    pub fn mlirFloat8E5M2FNUZTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E5M2FNUZ type."]
    pub fn mlirTypeIsAFloat8E5M2FNUZ(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E5M2FNUZ type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E5M2FNUZTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E5M2FNUZTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E4M3FNUZ type."]
    pub fn mlirFloat8E4M3FNUZTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E4M3FNUZ type."]
    pub fn mlirTypeIsAFloat8E4M3FNUZ(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E4M3FNUZ type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E4M3FNUZTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E4M3FNUZTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E4M3B11FNUZ type."]
    pub fn mlirFloat8E4M3B11FNUZTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E4M3B11FNUZ type."]
    pub fn mlirTypeIsAFloat8E4M3B11FNUZ(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E4M3B11FNUZ type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E4M3B11FNUZTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E4M3B11FNUZTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E3M4 type."]
    pub fn mlirFloat8E3M4TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E3M4 type."]
    pub fn mlirTypeIsAFloat8E3M4(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E3M4 type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E3M4TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E3M4TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float8E8M0FNU type."]
    pub fn mlirFloat8E8M0FNUTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f8E8M0FNU type."]
    pub fn mlirTypeIsAFloat8E8M0FNU(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f8E8M0FNU type in the given context. The type is owned by the\n context."]
    pub fn mlirFloat8E8M0FNUTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFloat8E8M0FNUTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an BFloat16 type."]
    pub fn mlirBFloat16TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a bf16 type."]
    pub fn mlirTypeIsABF16(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a bf16 type in the given context. The type is owned by the\n context."]
    pub fn mlirBF16TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirBF16TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float16 type."]
    pub fn mlirFloat16TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f16 type."]
    pub fn mlirTypeIsAF16(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f16 type in the given context. The type is owned by the\n context."]
    pub fn mlirF16TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirF16TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float32 type."]
    pub fn mlirFloat32TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f32 type."]
    pub fn mlirTypeIsAF32(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an f32 type in the given context. The type is owned by the\n context."]
    pub fn mlirF32TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirF32TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Float64 type."]
    pub fn mlirFloat64TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an f64 type."]
    pub fn mlirTypeIsAF64(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a f64 type in the given context. The type is owned by the\n context."]
    pub fn mlirF64TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirF64TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of a TF32 type."]
    pub fn mlirFloatTF32TypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an TF32 type."]
    pub fn mlirTypeIsATF32(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a TF32 type in the given context. The type is owned by the\n context."]
    pub fn mlirTF32TypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTF32TypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an None type."]
    pub fn mlirNoneTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a None type."]
    pub fn mlirTypeIsANone(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a None type in the given context. The type is owned by the\n context."]
    pub fn mlirNoneTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirNoneTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Complex type."]
    pub fn mlirComplexTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a Complex type."]
    pub fn mlirTypeIsAComplex(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a complex type with the given element type in the same context as\n the element type. The type is owned by the context."]
    pub fn mlirComplexTypeGet(elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirComplexTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the element type of the given complex type."]
    pub fn mlirComplexTypeGetElementType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a Shaped type."]
    pub fn mlirTypeIsAShaped(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the element type of the shaped type."]
    pub fn mlirShapedTypeGetElementType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Checks whether the given shaped type is ranked."]
    pub fn mlirShapedTypeHasRank(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the rank of the given ranked shaped type."]
    pub fn mlirShapedTypeGetRank(type_: MlirType) -> i64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given shaped type has a static shape."]
    pub fn mlirShapedTypeHasStaticShape(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the dim-th dimension of the given shaped type is dynamic."]
    pub fn mlirShapedTypeIsDynamicDim(type_: MlirType, dim: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the dim-th dimension of the given shaped type is static."]
    pub fn mlirShapedTypeIsStaticDim(type_: MlirType, dim: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the dim-th dimension of the given ranked shaped type."]
    pub fn mlirShapedTypeGetDimSize(type_: MlirType, dim: isize) -> i64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given value is used as a placeholder for dynamic sizes\n in shaped types."]
    pub fn mlirShapedTypeIsDynamicSize(size: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given shaped type dimension value is statically-sized."]
    pub fn mlirShapedTypeIsStaticSize(size: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the value indicating a dynamic size in a shaped type. Prefer\n mlirShapedTypeIsDynamicSize and mlirShapedTypeIsStaticSize to direct\n comparisons with this value."]
    pub fn mlirShapedTypeGetDynamicSize() -> i64;
}
unsafe extern "C" {
    #[doc = " Checks whether the given value is used as a placeholder for dynamic strides\n and offsets in shaped types."]
    pub fn mlirShapedTypeIsDynamicStrideOrOffset(val: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given dimension value of a stride or an offset is\n statically-sized."]
    pub fn mlirShapedTypeIsStaticStrideOrOffset(val: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the value indicating a dynamic stride or offset in a shaped type.\n Prefer mlirShapedTypeIsDynamicStrideOrOffset and\n mlirShapedTypeIsStaticStrideOrOffset to direct comparisons with this value."]
    pub fn mlirShapedTypeGetDynamicStrideOrOffset() -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Vector type."]
    pub fn mlirVectorTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a Vector type."]
    pub fn mlirTypeIsAVector(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a vector type of the shape identified by its rank and dimensions,\n with the given element type in the same context as the element type. The\n type is owned by the context."]
    pub fn mlirVectorTypeGet(rank: isize, shape: *const i64, elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirVectorTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirVectorTypeGet\" but returns a nullptr wrapping MlirType on\n illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirVectorTypeGetChecked(
        loc: MlirLocation,
        rank: isize,
        shape: *const i64,
        elementType: MlirType,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates a scalable vector type with the shape identified by its rank and\n dimensions. A subset of dimensions may be marked as scalable via the\n corresponding flag list, which is expected to have as many entries as the\n rank of the vector. The vector is created in the same context as the element\n type."]
    pub fn mlirVectorTypeGetScalable(
        rank: isize,
        shape: *const i64,
        scalable: *const bool,
        elementType: MlirType,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirVectorTypeGetScalable\" but returns a nullptr wrapping MlirType\n on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirVectorTypeGetScalableChecked(
        loc: MlirLocation,
        rank: isize,
        shape: *const i64,
        scalable: *const bool,
        elementType: MlirType,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Checks whether the given vector type is scalable, i.e., has at least one\n scalable dimension."]
    pub fn mlirVectorTypeIsScalable(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the \"dim\"-th dimension of the given vector is scalable."]
    pub fn mlirVectorTypeIsDimScalable(type_: MlirType, dim: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a Tensor type."]
    pub fn mlirTypeIsATensor(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an RankedTensor type."]
    pub fn mlirRankedTensorTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a ranked tensor type."]
    pub fn mlirTypeIsARankedTensor(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an UnrankedTensor type."]
    pub fn mlirUnrankedTensorTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an unranked tensor type."]
    pub fn mlirTypeIsAUnrankedTensor(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a tensor type of a fixed rank with the given shape, element type,\n and optional encoding in the same context as the element type. The type is\n owned by the context. Tensor types without any specific encoding field\n should assign mlirAttributeGetNull() to this parameter."]
    pub fn mlirRankedTensorTypeGet(
        rank: isize,
        shape: *const i64,
        elementType: MlirType,
        encoding: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirRankedTensorTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirRankedTensorTypeGet\" but returns a nullptr wrapping MlirType on\n illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirRankedTensorTypeGetChecked(
        loc: MlirLocation,
        rank: isize,
        shape: *const i64,
        elementType: MlirType,
        encoding: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Gets the 'encoding' attribute from the ranked tensor type, returning a null\n attribute if none."]
    pub fn mlirRankedTensorTypeGetEncoding(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates an unranked tensor type with the given element type in the same\n context as the element type. The type is owned by the context."]
    pub fn mlirUnrankedTensorTypeGet(elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirUnrankedTensorTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirUnrankedTensorTypeGet\" but returns a nullptr wrapping MlirType\n on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirUnrankedTensorTypeGetChecked(loc: MlirLocation, elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an MemRef type."]
    pub fn mlirMemRefTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a MemRef type."]
    pub fn mlirTypeIsAMemRef(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an UnrankedMemRef type."]
    pub fn mlirUnrankedMemRefTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an UnrankedMemRef type."]
    pub fn mlirTypeIsAUnrankedMemRef(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a MemRef type with the given rank and shape, a potentially empty\n list of affine layout maps, the given memory space and element type, in the\n same context as element type. The type is owned by the context."]
    pub fn mlirMemRefTypeGet(
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        layout: MlirAttribute,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirMemRefTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirMemRefTypeGet\" but returns a nullptr-wrapping MlirType o\n illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirMemRefTypeGetChecked(
        loc: MlirLocation,
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        layout: MlirAttribute,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates a MemRef type with the given rank, shape, memory space and element\n type in the same context as the element type. The type has no affine maps,\n i.e. represents a default row-major contiguous memref. The type is owned by\n the context."]
    pub fn mlirMemRefTypeContiguousGet(
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirMemRefTypeContiguousGet\" but returns a nullptr wrapping\n MlirType on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirMemRefTypeContiguousGetChecked(
        loc: MlirLocation,
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates an Unranked MemRef type with the given element type and in the given\n memory space. The type is owned by the context of element type."]
    pub fn mlirUnrankedMemRefTypeGet(elementType: MlirType, memorySpace: MlirAttribute) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirUnrankedMemRefTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Same as \"mlirUnrankedMemRefTypeGet\" but returns a nullptr wrapping\n MlirType on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirUnrankedMemRefTypeGetChecked(
        loc: MlirLocation,
        elementType: MlirType,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the layout of the given MemRef type."]
    pub fn mlirMemRefTypeGetLayout(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the affine map of the given MemRef type."]
    pub fn mlirMemRefTypeGetAffineMap(type_: MlirType) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the memory space of the given MemRef type."]
    pub fn mlirMemRefTypeGetMemorySpace(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the strides of the MemRef if the layout map is in strided form.\n Both strides and offset are out params. strides must point to pre-allocated\n memory of length equal to the rank of the memref."]
    pub fn mlirMemRefTypeGetStridesAndOffset(type_: MlirType, strides: *mut i64, offset: *mut i64)
    -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Returns the memory spcae of the given Unranked MemRef type."]
    pub fn mlirUnrankedMemrefGetMemorySpace(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Tuple type."]
    pub fn mlirTupleTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a tuple type."]
    pub fn mlirTypeIsATuple(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a tuple type that consists of the given list of elemental types. The\n type is owned by the context."]
    pub fn mlirTupleTypeGet(ctx: MlirContext, numElements: isize, elements: *const MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTupleTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of types contained in a tuple."]
    pub fn mlirTupleTypeGetNumTypes(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the pos-th type in the tuple type."]
    pub fn mlirTupleTypeGetType(type_: MlirType, pos: isize) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Function type."]
    pub fn mlirFunctionTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is a function type."]
    pub fn mlirTypeIsAFunction(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a function type, mapping a list of input types to result types."]
    pub fn mlirFunctionTypeGet(
        ctx: MlirContext,
        numInputs: isize,
        inputs: *const MlirType,
        numResults: isize,
        results: *const MlirType,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirFunctionTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of input types."]
    pub fn mlirFunctionTypeGetNumInputs(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the number of result types."]
    pub fn mlirFunctionTypeGetNumResults(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the pos-th input type."]
    pub fn mlirFunctionTypeGetInput(type_: MlirType, pos: isize) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the pos-th result type."]
    pub fn mlirFunctionTypeGetResult(type_: MlirType, pos: isize) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the typeID of an Opaque type."]
    pub fn mlirOpaqueTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Checks whether the given type is an opaque type."]
    pub fn mlirTypeIsAOpaque(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an opaque type in the given context associated with the dialect\n identified by its namespace. The type contains opaque byte data of the\n specified length (data need not be null-terminated)."]
    pub fn mlirOpaqueTypeGet(ctx: MlirContext, dialectNamespace: MlirStringRef, typeData: MlirStringRef) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirOpaqueTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the namespace of the dialect with which the given opaque type\n is associated. The namespace string is owned by the context."]
    pub fn mlirOpaqueTypeGetDialectNamespace(type_: MlirType) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the raw data as a string reference. The data remains live as long as\n the context in which the type lives."]
    pub fn mlirOpaqueTypeGetData(type_: MlirType) -> MlirStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPass {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirPass"][::std::mem::size_of::<MlirPass>() - 8usize];
    ["Alignment of MlirPass"][::std::mem::align_of::<MlirPass>() - 8usize];
    ["Offset of field: MlirPass::ptr"][::std::mem::offset_of!(MlirPass, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirExternalPass {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirExternalPass"][::std::mem::size_of::<MlirExternalPass>() - 8usize];
    ["Alignment of MlirExternalPass"][::std::mem::align_of::<MlirExternalPass>() - 8usize];
    ["Offset of field: MlirExternalPass::ptr"][::std::mem::offset_of!(MlirExternalPass, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPassManager {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirPassManager"][::std::mem::size_of::<MlirPassManager>() - 8usize];
    ["Alignment of MlirPassManager"][::std::mem::align_of::<MlirPassManager>() - 8usize];
    ["Offset of field: MlirPassManager::ptr"][::std::mem::offset_of!(MlirPassManager, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpPassManager {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirOpPassManager"][::std::mem::size_of::<MlirOpPassManager>() - 8usize];
    ["Alignment of MlirOpPassManager"][::std::mem::align_of::<MlirOpPassManager>() - 8usize];
    ["Offset of field: MlirOpPassManager::ptr"][::std::mem::offset_of!(MlirOpPassManager, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Create a new top-level PassManager with the default anchor."]
    pub fn mlirPassManagerCreate(ctx: MlirContext) -> MlirPassManager;
}
unsafe extern "C" {
    #[doc = " Create a new top-level PassManager anchored on `anchorOp`."]
    pub fn mlirPassManagerCreateOnOperation(ctx: MlirContext, anchorOp: MlirStringRef) -> MlirPassManager;
}
unsafe extern "C" {
    #[doc = " Destroy the provided PassManager."]
    pub fn mlirPassManagerDestroy(passManager: MlirPassManager);
}
unsafe extern "C" {
    #[doc = " Cast a top-level PassManager to a generic OpPassManager."]
    pub fn mlirPassManagerGetAsOpPassManager(passManager: MlirPassManager) -> MlirOpPassManager;
}
unsafe extern "C" {
    #[doc = " Run the provided `passManager` on the given `op`."]
    pub fn mlirPassManagerRunOnOp(passManager: MlirPassManager, op: MlirOperation) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Enable IR printing.\n The treePrintingPath argument is an optional path to a directory\n where the dumps will be produced. If it isn't provided then dumps\n are produced to stderr."]
    pub fn mlirPassManagerEnableIRPrinting(
        passManager: MlirPassManager,
        printBeforeAll: bool,
        printAfterAll: bool,
        printModuleScope: bool,
        printAfterOnlyOnChange: bool,
        printAfterOnlyOnFailure: bool,
        flags: MlirOpPrintingFlags,
        treePrintingPath: MlirStringRef,
    );
}
unsafe extern "C" {
    #[doc = " Enable / disable verify-each."]
    pub fn mlirPassManagerEnableVerifier(passManager: MlirPassManager, enable: bool);
}
unsafe extern "C" {
    #[doc = " Enable pass timing."]
    pub fn mlirPassManagerEnableTiming(passManager: MlirPassManager);
}
pub const MlirPassDisplayMode_MLIR_PASS_DISPLAY_MODE_LIST: MlirPassDisplayMode = 0;
pub const MlirPassDisplayMode_MLIR_PASS_DISPLAY_MODE_PIPELINE: MlirPassDisplayMode = 1;
#[doc = " Enumerated type of pass display modes.\n Mainly used in mlirPassManagerEnableStatistics."]
pub type MlirPassDisplayMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Enable pass statistics."]
    pub fn mlirPassManagerEnableStatistics(passManager: MlirPassManager, displayMode: MlirPassDisplayMode);
}
unsafe extern "C" {
    #[doc = " Nest an OpPassManager under the top-level PassManager, the nested\n passmanager will only run on operations matching the provided name.\n The returned OpPassManager will be destroyed when the parent is destroyed.\n To further nest more OpPassManager under the newly returned one, see\n `mlirOpPassManagerNest` below."]
    pub fn mlirPassManagerGetNestedUnder(
        passManager: MlirPassManager,
        operationName: MlirStringRef,
    ) -> MlirOpPassManager;
}
unsafe extern "C" {
    #[doc = " Nest an OpPassManager under the provided OpPassManager, the nested\n passmanager will only run on operations matching the provided name.\n The returned OpPassManager will be destroyed when the parent is destroyed."]
    pub fn mlirOpPassManagerGetNestedUnder(
        passManager: MlirOpPassManager,
        operationName: MlirStringRef,
    ) -> MlirOpPassManager;
}
unsafe extern "C" {
    #[doc = " Add a pass and transfer ownership to the provided top-level mlirPassManager.\n If the pass is not a generic operation pass or a ModulePass, a new\n OpPassManager is implicitly nested under the provided PassManager."]
    pub fn mlirPassManagerAddOwnedPass(passManager: MlirPassManager, pass: MlirPass);
}
unsafe extern "C" {
    #[doc = " Add a pass and transfer ownership to the provided mlirOpPassManager. If the\n pass is not a generic operation pass or matching the type of the provided\n PassManager, a new OpPassManager is implicitly nested under the provided\n PassManager."]
    pub fn mlirOpPassManagerAddOwnedPass(passManager: MlirOpPassManager, pass: MlirPass);
}
unsafe extern "C" {
    #[doc = " Parse a sequence of textual MLIR pass pipeline elements and add them to the\n provided OpPassManager. If parsing fails an error message is reported using\n the provided callback."]
    pub fn mlirOpPassManagerAddPipeline(
        passManager: MlirOpPassManager,
        pipelineElements: MlirStringRef,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Print a textual MLIR pass pipeline by sending chunks of the string\n representation and forwarding `userData to `callback`. Note that the\n callback may be called several times with consecutive chunks of the string."]
    pub fn mlirPrintPassPipeline(
        passManager: MlirOpPassManager,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Parse a textual MLIR pass pipeline and assign it to the provided\n OpPassManager. If parsing fails an error message is reported using the\n provided callback."]
    pub fn mlirParsePassPipeline(
        passManager: MlirOpPassManager,
        pipeline: MlirStringRef,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
#[doc = " Structure of external `MlirPass` callbacks.\n All callbacks are required to be set unless otherwise specified."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirExternalPassCallbacks {
    #[doc = " This callback is called from the pass is created.\n This is analogous to a C++ pass constructor."]
    pub construct: ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
    #[doc = " This callback is called when the pass is destroyed\n This is analogous to a C++ pass destructor."]
    pub destruct: ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
    #[doc = " This callback is optional.\n The callback is called before the pass is run, allowing a chance to\n initialize any complex state necessary for running the pass.\n See Pass::initialize(MLIRContext *)."]
    pub initialize: ::std::option::Option<
        unsafe extern "C" fn(ctx: MlirContext, userData: *mut ::std::os::raw::c_void) -> MlirLogicalResult,
    >,
    #[doc = " This callback is called when the pass is cloned.\n See Pass::clonePass()."]
    pub clone: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " This callback is called when the pass is run.\n See Pass::runOnOperation()."]
    pub run: ::std::option::Option<
        unsafe extern "C" fn(op: MlirOperation, pass: MlirExternalPass, userData: *mut ::std::os::raw::c_void),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirExternalPassCallbacks"][::std::mem::size_of::<MlirExternalPassCallbacks>() - 40usize];
    ["Alignment of MlirExternalPassCallbacks"][::std::mem::align_of::<MlirExternalPassCallbacks>() - 8usize];
    ["Offset of field: MlirExternalPassCallbacks::construct"]
        [::std::mem::offset_of!(MlirExternalPassCallbacks, construct) - 0usize];
    ["Offset of field: MlirExternalPassCallbacks::destruct"]
        [::std::mem::offset_of!(MlirExternalPassCallbacks, destruct) - 8usize];
    ["Offset of field: MlirExternalPassCallbacks::initialize"]
        [::std::mem::offset_of!(MlirExternalPassCallbacks, initialize) - 16usize];
    ["Offset of field: MlirExternalPassCallbacks::clone"]
        [::std::mem::offset_of!(MlirExternalPassCallbacks, clone) - 24usize];
    ["Offset of field: MlirExternalPassCallbacks::run"]
        [::std::mem::offset_of!(MlirExternalPassCallbacks, run) - 32usize];
};
unsafe extern "C" {
    #[doc = " Creates an external `MlirPass` that calls the supplied `callbacks` using the\n supplied `userData`. If `opName` is empty, the pass is a generic operation\n pass. Otherwise it is an operation pass specific to the specified pass name."]
    pub fn mlirCreateExternalPass(
        passID: MlirTypeID,
        name: MlirStringRef,
        argument: MlirStringRef,
        description: MlirStringRef,
        opName: MlirStringRef,
        nDependentDialects: isize,
        dependentDialects: *mut MlirDialectHandle,
        callbacks: MlirExternalPassCallbacks,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirPass;
}
unsafe extern "C" {
    #[doc = " This signals that the pass has failed. This is only valid to call during\n the `run` callback of `MlirExternalPassCallbacks`.\n See Pass::signalPassFailure()."]
    pub fn mlirExternalPassSignalFailure(pass: MlirExternalPass);
}
unsafe extern "C" {
    pub fn mlirRegisterConversionPasses();
}
unsafe extern "C" {
    pub fn mlirCreateConversionArithToAMDGPUConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionArithToAMDGPUConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionArithToAPFloatConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionArithToAPFloatConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionArithToArmSMEConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionArithToArmSMEConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionArithToLLVMConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionArithToLLVMConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertAMDGPUToROCDLPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertAMDGPUToROCDLPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertAffineForToGPUPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertAffineForToGPUPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertArithToEmitC() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertArithToEmitC();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertArithToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertArithToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertArmNeon2dToIntrPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertArmNeon2dToIntrPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertArmSMEToLLVM() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertArmSMEToLLVM();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertArmSMEToSCFPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertArmSMEToSCFPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertAsyncToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertAsyncToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertBufferizationToMemRefPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertBufferizationToMemRefPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertComplexToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertComplexToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertComplexToLibm() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertComplexToLibm();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertComplexToROCDLLibraryCalls() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertComplexToROCDLLibraryCalls();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertComplexToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertComplexToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertComplexToStandardPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertComplexToStandardPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertControlFlowToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertControlFlowToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertControlFlowToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertControlFlowToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertFuncToEmitC() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertFuncToEmitC();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertFuncToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertFuncToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertFuncToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertFuncToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertGPUToSPIRV() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertGPUToSPIRV();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertGpuOpsToLLVMSPVOps() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertGpuOpsToLLVMSPVOps();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertGpuOpsToNVVMOps() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertGpuOpsToNVVMOps();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertGpuOpsToROCDLOps() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertGpuOpsToROCDLOps();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertIndexToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertIndexToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertIndexToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertIndexToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertLinalgToStandardPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertLinalgToStandardPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToEmitC() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToEmitC();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToFuncs() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToFuncs();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToLibmPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToLibmPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToROCDL() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToROCDL();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMathToXeVM() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMathToXeVM();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMemRefToEmitC() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMemRefToEmitC();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertMemRefToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertMemRefToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertNVGPUToNVVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertNVGPUToNVVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertNVVMToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertNVVMToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertOpenACCToSCFPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertOpenACCToSCFPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertOpenMPToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertOpenMPToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertPDLToPDLInterpPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertPDLToPDLInterpPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertParallelLoopToGpuPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertParallelLoopToGpuPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertSCFToOpenMPPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertSCFToOpenMPPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertSPIRVToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertSPIRVToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertShapeConstraintsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertShapeConstraintsPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertShapeToStandardPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertShapeToStandardPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertShardToMPIPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertShardToMPIPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertTensorToLinalgPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertTensorToLinalgPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertTensorToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertTensorToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertToEmitC() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertToEmitC();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToAMX() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToAMX();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToArmSMEPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToArmSMEPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToGPU() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToGPU();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToSCF() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToSCF();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToSPIRVPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToSPIRVPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertVectorToXeGPU() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertVectorToXeGPU();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertXeGPUToXeVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertXeGPUToXeVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionConvertXeVMToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionConvertXeVMToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionFinalizeMemRefToLLVMConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionFinalizeMemRefToLLVMConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionGpuToLLVMConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionGpuToLLVMConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionLiftControlFlowToSCFPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionLiftControlFlowToSCFPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionLowerAffinePass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionLowerAffinePass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionLowerHostCodeToLLVMPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionLowerHostCodeToLLVMPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionMapMemRefStorageClass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionMapMemRefStorageClass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionMathToAPFloatConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionMathToAPFloatConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionReconcileUnrealizedCastsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionReconcileUnrealizedCastsPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionSCFToControlFlowPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionSCFToControlFlowPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionSCFToEmitC() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionSCFToEmitC();
}
unsafe extern "C" {
    pub fn mlirCreateConversionSCFToSPIRV() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionSCFToSPIRV();
}
unsafe extern "C" {
    pub fn mlirCreateConversionSetLLVMModuleDataLayoutPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionSetLLVMModuleDataLayoutPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionTosaToArithPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionTosaToArithPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionTosaToLinalg() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionTosaToLinalg();
}
unsafe extern "C" {
    pub fn mlirCreateConversionTosaToLinalgNamed() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionTosaToLinalgNamed();
}
unsafe extern "C" {
    pub fn mlirCreateConversionTosaToMLProgram() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionTosaToMLProgram();
}
unsafe extern "C" {
    pub fn mlirCreateConversionTosaToSCFPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionTosaToSCFPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionTosaToTensorPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionTosaToTensorPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionUBToLLVMConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionUBToLLVMConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateConversionUBToSPIRVConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterConversionUBToSPIRVConversionPass();
}
unsafe extern "C" {
    #[doc = " Sets the global debugging flag."]
    pub fn mlirEnableGlobalDebug(enable: bool);
}
unsafe extern "C" {
    #[doc = " Retuns `true` if the global debugging flag is set, false otherwise."]
    pub fn mlirIsGlobalDebugEnabled() -> bool;
}
unsafe extern "C" {
    #[doc = " Sets the current debug type, similarly to `-debug-only=type` in the\n command-line tools. Note that global debug should be enabled for any output\n to be produced."]
    pub fn mlirSetGlobalDebugType(type_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Sets multiple current debug types, similarly to `-debug-only=type1,type2\" in\n the command-line tools. Note that global debug should be enabled for any\n output to be produced."]
    pub fn mlirSetGlobalDebugTypes(types: *mut *const ::std::os::raw::c_char, n: isize);
}
unsafe extern "C" {
    #[doc = " Checks if `type` is set as the current debug type."]
    pub fn mlirIsCurrentDebugType(type_: *const ::std::os::raw::c_char) -> bool;
}
#[doc = " An opaque reference to a diagnostic, always owned by the diagnostics engine\n (context). Must not be stored outside of the diagnostic handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDiagnostic {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirDiagnostic"][::std::mem::size_of::<MlirDiagnostic>() - 8usize];
    ["Alignment of MlirDiagnostic"][::std::mem::align_of::<MlirDiagnostic>() - 8usize];
    ["Offset of field: MlirDiagnostic::ptr"][::std::mem::offset_of!(MlirDiagnostic, ptr) - 0usize];
};
pub const MlirDiagnosticSeverity_MlirDiagnosticError: MlirDiagnosticSeverity = 0;
pub const MlirDiagnosticSeverity_MlirDiagnosticWarning: MlirDiagnosticSeverity = 1;
pub const MlirDiagnosticSeverity_MlirDiagnosticNote: MlirDiagnosticSeverity = 2;
pub const MlirDiagnosticSeverity_MlirDiagnosticRemark: MlirDiagnosticSeverity = 3;
#[doc = " Severity of a diagnostic."]
pub type MlirDiagnosticSeverity = ::std::os::raw::c_uint;
#[doc = " Opaque identifier of a diagnostic handler, useful to detach a handler."]
pub type MlirDiagnosticHandlerID = u64;
#[doc = " Diagnostic handler type. Accepts a reference to a diagnostic, which is only\n guaranteed to be live during the call. The handler is passed the `userData`\n that was provided when the handler was attached to a context. If the handler\n processed the diagnostic completely, it is expected to return success.\n Otherwise, it is expected to return failure to indicate that other handlers\n should attempt to process the diagnostic."]
pub type MlirDiagnosticHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: MlirDiagnostic, userData: *mut ::std::os::raw::c_void) -> MlirLogicalResult,
>;
unsafe extern "C" {
    #[doc = " Prints a diagnostic using the provided callback."]
    pub fn mlirDiagnosticPrint(
        diagnostic: MlirDiagnostic,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Returns the location at which the diagnostic is reported."]
    pub fn mlirDiagnosticGetLocation(diagnostic: MlirDiagnostic) -> MlirLocation;
}
unsafe extern "C" {
    #[doc = " Returns the severity of the diagnostic."]
    pub fn mlirDiagnosticGetSeverity(diagnostic: MlirDiagnostic) -> MlirDiagnosticSeverity;
}
unsafe extern "C" {
    #[doc = " Returns the number of notes attached to the diagnostic."]
    pub fn mlirDiagnosticGetNumNotes(diagnostic: MlirDiagnostic) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th note attached to the diagnostic. Expects `pos` to be a\n valid zero-based index into the list of notes."]
    pub fn mlirDiagnosticGetNote(diagnostic: MlirDiagnostic, pos: isize) -> MlirDiagnostic;
}
unsafe extern "C" {
    #[doc = " Attaches the diagnostic handler to the context. Handlers are invoked in the\n reverse order of attachment until one of them processes the diagnostic\n completely. When a handler is invoked it is passed the `userData` that was\n provided when it was attached. If non-NULL, `deleteUserData` is called once\n the system no longer needs to call the handler (for instance after the\n handler is detached or the context is destroyed). Returns an identifier that\n can be used to detach the handler."]
    pub fn mlirContextAttachDiagnosticHandler(
        context: MlirContext,
        handler: MlirDiagnosticHandler,
        userData: *mut ::std::os::raw::c_void,
        deleteUserData: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> MlirDiagnosticHandlerID;
}
unsafe extern "C" {
    #[doc = " Detaches an attached diagnostic handler from the context given its\n identifier."]
    pub fn mlirContextDetachDiagnosticHandler(context: MlirContext, id: MlirDiagnosticHandlerID);
}
unsafe extern "C" {
    #[doc = " Emits an error at the given location through the diagnostics engine. Used\n for testing purposes."]
    pub fn mlirEmitError(location: MlirLocation, message: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirExecutionEngine {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirExecutionEngine"][::std::mem::size_of::<MlirExecutionEngine>() - 8usize];
    ["Alignment of MlirExecutionEngine"][::std::mem::align_of::<MlirExecutionEngine>() - 8usize];
    ["Offset of field: MlirExecutionEngine::ptr"][::std::mem::offset_of!(MlirExecutionEngine, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Creates an ExecutionEngine for the provided ModuleOp. The ModuleOp is\n expected to be \"translatable\" to LLVM IR (only contains operations in\n dialects that implement the `LLVMTranslationDialectInterface`). The module\n ownership stays with the client and can be destroyed as soon as the call\n returns. `optLevel` is the optimization level to be used for transformation\n and code generation. LLVM passes at `optLevel` are run before code\n generation. The number and array of paths corresponding to shared libraries\n that will be loaded are specified via `numPaths` and `sharedLibPaths`\n respectively.\n The `enablePIC` arguments controls the relocation model, when true the\n generated code is emitted as \"position independent\", making it possible to\n save it and reload it as a shared object in another process.\n TODO: figure out other options."]
    pub fn mlirExecutionEngineCreate(
        op: MlirModule,
        optLevel: ::std::os::raw::c_int,
        numPaths: ::std::os::raw::c_int,
        sharedLibPaths: *const MlirStringRef,
        enableObjectDump: bool,
        enablePIC: bool,
    ) -> MlirExecutionEngine;
}
unsafe extern "C" {
    #[doc = " Initialize the ExecutionEngine. Global constructors specified by\n `llvm.mlir.global_ctors` will be run. One common scenario is that kernel\n binary compiled from `gpu.module` gets loaded during initialization. Make\n sure all symbols are resolvable before initialization by calling\n `mlirExecutionEngineRegisterSymbol` or including shared libraries."]
    pub fn mlirExecutionEngineInitialize(jit: MlirExecutionEngine);
}
unsafe extern "C" {
    #[doc = " Destroy an ExecutionEngine instance."]
    pub fn mlirExecutionEngineDestroy(jit: MlirExecutionEngine);
}
unsafe extern "C" {
    #[doc = " Invoke a native function in the execution engine by name with the arguments\n and result of the invoked function passed as an array of pointers. The\n function must have been tagged with the `llvm.emit_c_interface` attribute.\n Returns a failure if the execution fails for any reason (the function name\n can't be resolved for instance)."]
    pub fn mlirExecutionEngineInvokePacked(
        jit: MlirExecutionEngine,
        name: MlirStringRef,
        arguments: *mut *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Lookup the wrapper of the native function in the execution engine with the\n given name, returns nullptr if the function can't be looked-up."]
    pub fn mlirExecutionEngineLookupPacked(
        jit: MlirExecutionEngine,
        name: MlirStringRef,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Lookup a native function in the execution engine by name, returns nullptr\n if the name can't be looked-up."]
    pub fn mlirExecutionEngineLookup(jit: MlirExecutionEngine, name: MlirStringRef) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Register a symbol with the jit: this symbol will be accessible to the jitted\n code."]
    pub fn mlirExecutionEngineRegisterSymbol(
        jit: MlirExecutionEngine,
        name: MlirStringRef,
        sym: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Dump as an object in `fileName`."]
    pub fn mlirExecutionEngineDumpToObjectFile(jit: MlirExecutionEngine, fileName: MlirStringRef);
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given operation implements an interface identified by\n its TypeID."]
    pub fn mlirOperationImplementsInterface(operation: MlirOperation, interfaceTypeID: MlirTypeID) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the operation identified by its canonical string name\n implements the interface identified by its TypeID in the given context.\n Note that interfaces may be attached to operations in some contexts and not\n others."]
    pub fn mlirOperationImplementsInterfaceStatic(
        operationName: MlirStringRef,
        context: MlirContext,
        interfaceTypeID: MlirTypeID,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the interface TypeID of the InferTypeOpInterface."]
    pub fn mlirInferTypeOpInterfaceTypeID() -> MlirTypeID;
}
#[doc = " These callbacks are used to return multiple types from functions while\n transferring ownership to the caller. The first argument is the number of\n consecutive elements pointed to by the second argument. The third argument\n is an opaque pointer forwarded to the callback by the caller."]
pub type MlirTypesCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: isize, arg2: *mut MlirType, arg3: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    #[doc = " Infers the return types of the operation identified by its canonical given\n the arguments that will be supplied to its generic builder. Calls `callback`\n with the types of inferred arguments, potentially several times, on success.\n Returns failure otherwise."]
    pub fn mlirInferTypeOpInterfaceInferReturnTypes(
        opName: MlirStringRef,
        context: MlirContext,
        location: MlirLocation,
        nOperands: isize,
        operands: *mut MlirValue,
        attributes: MlirAttribute,
        properties: *mut ::std::os::raw::c_void,
        nRegions: isize,
        regions: *mut MlirRegion,
        callback: MlirTypesCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Returns the interface TypeID of the InferShapedTypeOpInterface."]
    pub fn mlirInferShapedTypeOpInterfaceTypeID() -> MlirTypeID;
}
#[doc = " These callbacks are used to return multiple shaped type components from\n functions while transferring ownership to the caller. The first argument is\n the has rank boolean followed by the the rank and a pointer to the shape\n (if applicable). The next argument is the element type, then the attribute.\n The last argument is an opaque pointer forwarded to the callback by the\n caller. This callback will be called potentially multiple times for each\n shaped type components."]
pub type MlirShapedTypeComponentsCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: bool,
        arg2: isize,
        arg3: *const i64,
        arg4: MlirType,
        arg5: MlirAttribute,
        arg6: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Infers the return shaped type components of the operation. Calls `callback`\n with the types of inferred arguments on success. Returns failure otherwise."]
    pub fn mlirInferShapedTypeOpInterfaceInferReturnTypes(
        opName: MlirStringRef,
        context: MlirContext,
        location: MlirLocation,
        nOperands: isize,
        operands: *mut MlirValue,
        attributes: MlirAttribute,
        properties: *mut ::std::os::raw::c_void,
        nRegions: isize,
        regions: *mut MlirRegion,
        callback: MlirShapedTypeComponentsCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRewriterBase {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirRewriterBase"][::std::mem::size_of::<MlirRewriterBase>() - 8usize];
    ["Alignment of MlirRewriterBase"][::std::mem::align_of::<MlirRewriterBase>() - 8usize];
    ["Offset of field: MlirRewriterBase::ptr"][::std::mem::offset_of!(MlirRewriterBase, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirFrozenRewritePatternSet {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirFrozenRewritePatternSet"][::std::mem::size_of::<MlirFrozenRewritePatternSet>() - 8usize];
    ["Alignment of MlirFrozenRewritePatternSet"][::std::mem::align_of::<MlirFrozenRewritePatternSet>() - 8usize];
    ["Offset of field: MlirFrozenRewritePatternSet::ptr"]
        [::std::mem::offset_of!(MlirFrozenRewritePatternSet, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirGreedyRewriteDriverConfig {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirGreedyRewriteDriverConfig"][::std::mem::size_of::<MlirGreedyRewriteDriverConfig>() - 8usize];
    ["Alignment of MlirGreedyRewriteDriverConfig"][::std::mem::align_of::<MlirGreedyRewriteDriverConfig>() - 8usize];
    ["Offset of field: MlirGreedyRewriteDriverConfig::ptr"]
        [::std::mem::offset_of!(MlirGreedyRewriteDriverConfig, ptr) - 0usize];
};
#[doc = " No restrictions wrt. which ops are processed."]
pub const MlirGreedyRewriteStrictness_MLIR_GREEDY_REWRITE_STRICTNESS_ANY_OP: MlirGreedyRewriteStrictness = 0;
#[doc = " Only pre-existing and newly created ops are processed."]
pub const MlirGreedyRewriteStrictness_MLIR_GREEDY_REWRITE_STRICTNESS_EXISTING_AND_NEW_OPS: MlirGreedyRewriteStrictness =
    1;
#[doc = " Only pre-existing ops are processed."]
pub const MlirGreedyRewriteStrictness_MLIR_GREEDY_REWRITE_STRICTNESS_EXISTING_OPS: MlirGreedyRewriteStrictness = 2;
#[doc = " Greedy rewrite strictness levels."]
pub type MlirGreedyRewriteStrictness = ::std::os::raw::c_uint;
#[doc = " Disable region control-flow simplification."]
pub const MlirGreedySimplifyRegionLevel_MLIR_GREEDY_SIMPLIFY_REGION_LEVEL_DISABLED: MlirGreedySimplifyRegionLevel = 0;
#[doc = " Run the normal simplification (e.g. dead args elimination)."]
pub const MlirGreedySimplifyRegionLevel_MLIR_GREEDY_SIMPLIFY_REGION_LEVEL_NORMAL: MlirGreedySimplifyRegionLevel = 1;
#[doc = " Run extra simplifications (e.g. block merging)."]
pub const MlirGreedySimplifyRegionLevel_MLIR_GREEDY_SIMPLIFY_REGION_LEVEL_AGGRESSIVE: MlirGreedySimplifyRegionLevel = 2;
#[doc = " Greedy simplify region levels."]
pub type MlirGreedySimplifyRegionLevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRewritePatternSet {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirRewritePatternSet"][::std::mem::size_of::<MlirRewritePatternSet>() - 8usize];
    ["Alignment of MlirRewritePatternSet"][::std::mem::align_of::<MlirRewritePatternSet>() - 8usize];
    ["Offset of field: MlirRewritePatternSet::ptr"][::std::mem::offset_of!(MlirRewritePatternSet, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPatternRewriter {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirPatternRewriter"][::std::mem::size_of::<MlirPatternRewriter>() - 8usize];
    ["Alignment of MlirPatternRewriter"][::std::mem::align_of::<MlirPatternRewriter>() - 8usize];
    ["Offset of field: MlirPatternRewriter::ptr"][::std::mem::offset_of!(MlirPatternRewriter, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRewritePattern {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirRewritePattern"][::std::mem::size_of::<MlirRewritePattern>() - 8usize];
    ["Alignment of MlirRewritePattern"][::std::mem::align_of::<MlirRewritePattern>() - 8usize];
    ["Offset of field: MlirRewritePattern::ptr"][::std::mem::offset_of!(MlirRewritePattern, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Get the MLIR context referenced by the rewriter."]
    pub fn mlirRewriterBaseGetContext(rewriter: MlirRewriterBase) -> MlirContext;
}
unsafe extern "C" {
    #[doc = " Reset the insertion point to no location.  Creating an operation without a\n set insertion point is an error, but this can still be useful when the\n current insertion point a builder refers to is being removed."]
    pub fn mlirRewriterBaseClearInsertionPoint(rewriter: MlirRewriterBase);
}
unsafe extern "C" {
    #[doc = " Sets the insertion point to the specified operation, which will cause\n subsequent insertions to go right before it."]
    pub fn mlirRewriterBaseSetInsertionPointBefore(rewriter: MlirRewriterBase, op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Sets the insertion point to the node after the specified operation, which\n will cause subsequent insertions to go right after it."]
    pub fn mlirRewriterBaseSetInsertionPointAfter(rewriter: MlirRewriterBase, op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Sets the insertion point to the node after the specified value. If value\n has a defining operation, sets the insertion point to the node after such\n defining operation. This will cause subsequent insertions to go right\n after it. Otherwise, value is a BlockArgument. Sets the insertion point to\n the start of its block."]
    pub fn mlirRewriterBaseSetInsertionPointAfterValue(rewriter: MlirRewriterBase, value: MlirValue);
}
unsafe extern "C" {
    #[doc = " Sets the insertion point to the start of the specified block."]
    pub fn mlirRewriterBaseSetInsertionPointToStart(rewriter: MlirRewriterBase, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Sets the insertion point to the end of the specified block."]
    pub fn mlirRewriterBaseSetInsertionPointToEnd(rewriter: MlirRewriterBase, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Return the block the current insertion point belongs to.  Note that the\n insertion point is not necessarily the end of the block."]
    pub fn mlirRewriterBaseGetInsertionBlock(rewriter: MlirRewriterBase) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Returns the current block of the rewriter."]
    pub fn mlirRewriterBaseGetBlock(rewriter: MlirRewriterBase) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Returns the operation right after the current insertion point\n of the rewriter. A null MlirOperation will be returned"]
    pub fn mlirRewriterBaseGetOperationAfterInsertion(rewriter: MlirRewriterBase) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Add new block with 'argTypes' arguments and set the insertion point to the\n end of it. The block is placed before 'insertBefore'. `locs` contains the\n locations of the inserted arguments, and should match the size of\n `argTypes`."]
    pub fn mlirRewriterBaseCreateBlockBefore(
        rewriter: MlirRewriterBase,
        insertBefore: MlirBlock,
        nArgTypes: isize,
        argTypes: *const MlirType,
        locations: *const MlirLocation,
    ) -> MlirBlock;
}
unsafe extern "C" {
    #[doc = " Insert the given operation at the current insertion point and return it."]
    pub fn mlirRewriterBaseInsert(rewriter: MlirRewriterBase, op: MlirOperation) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Creates a deep copy of the specified operation."]
    pub fn mlirRewriterBaseClone(rewriter: MlirRewriterBase, op: MlirOperation) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Creates a deep copy of this operation but keep the operation regions\n empty."]
    pub fn mlirRewriterBaseCloneWithoutRegions(rewriter: MlirRewriterBase, op: MlirOperation) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Clone the blocks that belong to \"region\" before the given position in\n another region \"parent\"."]
    pub fn mlirRewriterBaseCloneRegionBefore(rewriter: MlirRewriterBase, region: MlirRegion, before: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Move the blocks that belong to \"region\" before the given position in\n another region \"parent\". The two regions must be different. The caller\n is responsible for creating or updating the operation transferring flow\n of control to the region and passing it the correct block arguments."]
    pub fn mlirRewriterBaseInlineRegionBefore(rewriter: MlirRewriterBase, region: MlirRegion, before: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Replace the results of the given (original) operation with the specified\n list of values (replacements). The result types of the given op and the\n replacements must match. The original op is erased."]
    pub fn mlirRewriterBaseReplaceOpWithValues(
        rewriter: MlirRewriterBase,
        op: MlirOperation,
        nValues: isize,
        values: *const MlirValue,
    );
}
unsafe extern "C" {
    #[doc = " Replace the results of the given (original) operation with the specified\n new op (replacement). The result types of the two ops must match. The\n original op is erased."]
    pub fn mlirRewriterBaseReplaceOpWithOperation(rewriter: MlirRewriterBase, op: MlirOperation, newOp: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Erases an operation that is known to have no uses."]
    pub fn mlirRewriterBaseEraseOp(rewriter: MlirRewriterBase, op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Erases a block along with all operations inside it."]
    pub fn mlirRewriterBaseEraseBlock(rewriter: MlirRewriterBase, block: MlirBlock);
}
unsafe extern "C" {
    #[doc = " Inline the operations of block 'source' before the operation 'op'. The\n source block will be deleted and must have no uses. 'argValues' is used to\n replace the block arguments of 'source'\n\n The source block must have no successors. Otherwise, the resulting IR\n would have unreachable operations."]
    pub fn mlirRewriterBaseInlineBlockBefore(
        rewriter: MlirRewriterBase,
        source: MlirBlock,
        op: MlirOperation,
        nArgValues: isize,
        argValues: *const MlirValue,
    );
}
unsafe extern "C" {
    #[doc = " Inline the operations of block 'source' into the end of block 'dest'. The\n source block will be deleted and must have no uses. 'argValues' is used to\n replace the block arguments of 'source'\n\n The dest block must have no successors. Otherwise, the resulting IR would\n have unreachable operation."]
    pub fn mlirRewriterBaseMergeBlocks(
        rewriter: MlirRewriterBase,
        source: MlirBlock,
        dest: MlirBlock,
        nArgValues: isize,
        argValues: *const MlirValue,
    );
}
unsafe extern "C" {
    #[doc = " Unlink this operation from its current block and insert it right before\n `existingOp` which may be in the same or another block in the same\n function."]
    pub fn mlirRewriterBaseMoveOpBefore(rewriter: MlirRewriterBase, op: MlirOperation, existingOp: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Unlink this operation from its current block and insert it right after\n `existingOp` which may be in the same or another block in the same\n function."]
    pub fn mlirRewriterBaseMoveOpAfter(rewriter: MlirRewriterBase, op: MlirOperation, existingOp: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Unlink this block and insert it right before `existingBlock`."]
    pub fn mlirRewriterBaseMoveBlockBefore(rewriter: MlirRewriterBase, block: MlirBlock, existingBlock: MlirBlock);
}
unsafe extern "C" {
    #[doc = " This method is used to notify the rewriter that an in-place operation\n modification is about to happen. A call to this function *must* be\n followed by a call to either `finalizeOpModification` or\n `cancelOpModification`. This is a minor efficiency win (it avoids creating\n a new operation and removing the old one) but also often allows simpler\n code in the client."]
    pub fn mlirRewriterBaseStartOpModification(rewriter: MlirRewriterBase, op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " This method is used to signal the end of an in-place modification of the\n given operation. This can only be called on operations that were provided\n to a call to `startOpModification`."]
    pub fn mlirRewriterBaseFinalizeOpModification(rewriter: MlirRewriterBase, op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " This method cancels a pending in-place modification. This can only be\n called on operations that were provided to a call to\n `startOpModification`."]
    pub fn mlirRewriterBaseCancelOpModification(rewriter: MlirRewriterBase, op: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Find uses of `from` and replace them with `to`. Also notify the listener\n about every in-place op modification (for every use that was replaced)."]
    pub fn mlirRewriterBaseReplaceAllUsesWith(rewriter: MlirRewriterBase, from: MlirValue, to: MlirValue);
}
unsafe extern "C" {
    #[doc = " Find uses of `from` and replace them with `to`. Also notify the listener\n about every in-place op modification (for every use that was replaced)."]
    pub fn mlirRewriterBaseReplaceAllValueRangeUsesWith(
        rewriter: MlirRewriterBase,
        nValues: isize,
        from: *const MlirValue,
        to: *const MlirValue,
    );
}
unsafe extern "C" {
    #[doc = " Find uses of `from` and replace them with `to`. Also notify the listener\n about every in-place op modification (for every use that was replaced)\n and that the `from` operation is about to be replaced."]
    pub fn mlirRewriterBaseReplaceAllOpUsesWithValueRange(
        rewriter: MlirRewriterBase,
        from: MlirOperation,
        nTo: isize,
        to: *const MlirValue,
    );
}
unsafe extern "C" {
    #[doc = " Find uses of `from` and replace them with `to`. Also notify the listener\n about every in-place op modification (for every use that was replaced)\n and that the `from` operation is about to be replaced."]
    pub fn mlirRewriterBaseReplaceAllOpUsesWithOperation(
        rewriter: MlirRewriterBase,
        from: MlirOperation,
        to: MlirOperation,
    );
}
unsafe extern "C" {
    #[doc = " Find uses of `from` within `block` and replace them with `to`. Also notify\n the listener about every in-place op modification (for every use that was\n replaced). The optional `allUsesReplaced` flag is set to \"true\" if all\n uses were replaced."]
    pub fn mlirRewriterBaseReplaceOpUsesWithinBlock(
        rewriter: MlirRewriterBase,
        op: MlirOperation,
        nNewValues: isize,
        newValues: *const MlirValue,
        block: MlirBlock,
    );
}
unsafe extern "C" {
    #[doc = " Find uses of `from` and replace them with `to` except if the user is\n `exceptedUser`. Also notify the listener about every in-place op\n modification (for every use that was replaced)."]
    pub fn mlirRewriterBaseReplaceAllUsesExcept(
        rewriter: MlirRewriterBase,
        from: MlirValue,
        to: MlirValue,
        exceptedUser: MlirOperation,
    );
}
unsafe extern "C" {
    #[doc = " Create an IRRewriter and transfer ownership to the caller."]
    pub fn mlirIRRewriterCreate(context: MlirContext) -> MlirRewriterBase;
}
unsafe extern "C" {
    #[doc = " Create an IRRewriter and transfer ownership to the caller. Additionally\n set the insertion point before the operation."]
    pub fn mlirIRRewriterCreateFromOp(op: MlirOperation) -> MlirRewriterBase;
}
unsafe extern "C" {
    #[doc = " Takes an IRRewriter owned by the caller and destroys it. It is the\n responsibility of the user to only pass an IRRewriter class."]
    pub fn mlirIRRewriterDestroy(rewriter: MlirRewriterBase);
}
unsafe extern "C" {
    #[doc = " Freeze the given MlirRewritePatternSet to a MlirFrozenRewritePatternSet.\n Note that the ownership of the input set is transferred into the frozen set\n after this call."]
    pub fn mlirFreezeRewritePattern(set: MlirRewritePatternSet) -> MlirFrozenRewritePatternSet;
}
unsafe extern "C" {
    #[doc = " Destroy the given MlirFrozenRewritePatternSet."]
    pub fn mlirFrozenRewritePatternSetDestroy(set: MlirFrozenRewritePatternSet);
}
unsafe extern "C" {
    pub fn mlirApplyPatternsAndFoldGreedilyWithOp(
        op: MlirOperation,
        patterns: MlirFrozenRewritePatternSet,
        arg1: MlirGreedyRewriteDriverConfig,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn mlirApplyPatternsAndFoldGreedily(
        op: MlirModule,
        patterns: MlirFrozenRewritePatternSet,
        config: MlirGreedyRewriteDriverConfig,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Creates a greedy rewrite driver configuration with default settings."]
    pub fn mlirGreedyRewriteDriverConfigCreate() -> MlirGreedyRewriteDriverConfig;
}
unsafe extern "C" {
    #[doc = " Destroys a greedy rewrite driver configuration."]
    pub fn mlirGreedyRewriteDriverConfigDestroy(config: MlirGreedyRewriteDriverConfig);
}
unsafe extern "C" {
    #[doc = " Sets the maximum number of iterations for the greedy rewrite driver.\n Use -1 for no limit."]
    pub fn mlirGreedyRewriteDriverConfigSetMaxIterations(config: MlirGreedyRewriteDriverConfig, maxIterations: i64);
}
unsafe extern "C" {
    #[doc = " Sets the maximum number of rewrites within an iteration.\n Use -1 for no limit."]
    pub fn mlirGreedyRewriteDriverConfigSetMaxNumRewrites(config: MlirGreedyRewriteDriverConfig, maxNumRewrites: i64);
}
unsafe extern "C" {
    #[doc = " Sets whether to use top-down traversal for the initial population of the\n worklist."]
    pub fn mlirGreedyRewriteDriverConfigSetUseTopDownTraversal(
        config: MlirGreedyRewriteDriverConfig,
        useTopDownTraversal: bool,
    );
}
unsafe extern "C" {
    #[doc = " Enables or disables folding during greedy rewriting."]
    pub fn mlirGreedyRewriteDriverConfigEnableFolding(config: MlirGreedyRewriteDriverConfig, enable: bool);
}
unsafe extern "C" {
    #[doc = " Sets the strictness level for the greedy rewrite driver."]
    pub fn mlirGreedyRewriteDriverConfigSetStrictness(
        config: MlirGreedyRewriteDriverConfig,
        strictness: MlirGreedyRewriteStrictness,
    );
}
unsafe extern "C" {
    #[doc = " Sets the region simplification level."]
    pub fn mlirGreedyRewriteDriverConfigSetRegionSimplificationLevel(
        config: MlirGreedyRewriteDriverConfig,
        level: MlirGreedySimplifyRegionLevel,
    );
}
unsafe extern "C" {
    #[doc = " Enables or disables constant CSE."]
    pub fn mlirGreedyRewriteDriverConfigEnableConstantCSE(config: MlirGreedyRewriteDriverConfig, enable: bool);
}
unsafe extern "C" {
    #[doc = " Gets the maximum number of iterations for the greedy rewrite driver."]
    pub fn mlirGreedyRewriteDriverConfigGetMaxIterations(config: MlirGreedyRewriteDriverConfig) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the maximum number of rewrites within an iteration."]
    pub fn mlirGreedyRewriteDriverConfigGetMaxNumRewrites(config: MlirGreedyRewriteDriverConfig) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets whether top-down traversal is used for initial worklist population."]
    pub fn mlirGreedyRewriteDriverConfigGetUseTopDownTraversal(config: MlirGreedyRewriteDriverConfig) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets whether folding is enabled during greedy rewriting."]
    pub fn mlirGreedyRewriteDriverConfigIsFoldingEnabled(config: MlirGreedyRewriteDriverConfig) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the strictness level for the greedy rewrite driver."]
    pub fn mlirGreedyRewriteDriverConfigGetStrictness(
        config: MlirGreedyRewriteDriverConfig,
    ) -> MlirGreedyRewriteStrictness;
}
unsafe extern "C" {
    #[doc = " Gets the region simplification level."]
    pub fn mlirGreedyRewriteDriverConfigGetRegionSimplificationLevel(
        config: MlirGreedyRewriteDriverConfig,
    ) -> MlirGreedySimplifyRegionLevel;
}
unsafe extern "C" {
    #[doc = " Gets whether constant CSE is enabled."]
    pub fn mlirGreedyRewriteDriverConfigIsConstantCSEEnabled(config: MlirGreedyRewriteDriverConfig) -> bool;
}
unsafe extern "C" {
    #[doc = " Applies the given patterns to the given op by a fast walk-based pattern\n rewrite driver."]
    pub fn mlirWalkAndApplyPatterns(op: MlirOperation, patterns: MlirFrozenRewritePatternSet);
}
unsafe extern "C" {
    #[doc = " Cast the PatternRewriter to a RewriterBase"]
    pub fn mlirPatternRewriterAsBase(rewriter: MlirPatternRewriter) -> MlirRewriterBase;
}
#[doc = " Callbacks to construct a rewrite pattern."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRewritePatternCallbacks {
    #[doc = " Optional constructor for the user data.\n Set to nullptr to disable it."]
    pub construct: ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
    #[doc = " Optional destructor for the user data.\n Set to nullptr to disable it."]
    pub destruct: ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
    #[doc = " The callback function to match against code rooted at the specified\n operation, and perform the rewrite if the match is successful,\n corresponding to RewritePattern::matchAndRewrite."]
    pub matchAndRewrite: ::std::option::Option<
        unsafe extern "C" fn(
            pattern: MlirRewritePattern,
            op: MlirOperation,
            rewriter: MlirPatternRewriter,
            userData: *mut ::std::os::raw::c_void,
        ) -> MlirLogicalResult,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirRewritePatternCallbacks"][::std::mem::size_of::<MlirRewritePatternCallbacks>() - 24usize];
    ["Alignment of MlirRewritePatternCallbacks"][::std::mem::align_of::<MlirRewritePatternCallbacks>() - 8usize];
    ["Offset of field: MlirRewritePatternCallbacks::construct"]
        [::std::mem::offset_of!(MlirRewritePatternCallbacks, construct) - 0usize];
    ["Offset of field: MlirRewritePatternCallbacks::destruct"]
        [::std::mem::offset_of!(MlirRewritePatternCallbacks, destruct) - 8usize];
    ["Offset of field: MlirRewritePatternCallbacks::matchAndRewrite"]
        [::std::mem::offset_of!(MlirRewritePatternCallbacks, matchAndRewrite) - 16usize];
};
unsafe extern "C" {
    #[doc = " Create a rewrite pattern that matches the operation\n with the given rootName, corresponding to mlir::OpRewritePattern."]
    pub fn mlirOpRewritePatternCreate(
        rootName: MlirStringRef,
        benefit: ::std::os::raw::c_uint,
        context: MlirContext,
        callbacks: MlirRewritePatternCallbacks,
        userData: *mut ::std::os::raw::c_void,
        nGeneratedNames: usize,
        generatedNames: *mut MlirStringRef,
    ) -> MlirRewritePattern;
}
unsafe extern "C" {
    #[doc = " Create an empty MlirRewritePatternSet."]
    pub fn mlirRewritePatternSetCreate(context: MlirContext) -> MlirRewritePatternSet;
}
unsafe extern "C" {
    #[doc = " Destruct the given MlirRewritePatternSet."]
    pub fn mlirRewritePatternSetDestroy(set: MlirRewritePatternSet);
}
unsafe extern "C" {
    #[doc = " Add the given MlirRewritePattern into a MlirRewritePatternSet.\n Note that the ownership of the pattern is transferred to the set after this\n call."]
    pub fn mlirRewritePatternSetAdd(set: MlirRewritePatternSet, pattern: MlirRewritePattern);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPDLPatternModule {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirPDLPatternModule"][::std::mem::size_of::<MlirPDLPatternModule>() - 8usize];
    ["Alignment of MlirPDLPatternModule"][::std::mem::align_of::<MlirPDLPatternModule>() - 8usize];
    ["Offset of field: MlirPDLPatternModule::ptr"][::std::mem::offset_of!(MlirPDLPatternModule, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPDLValue {
    pub ptr: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirPDLValue"][::std::mem::size_of::<MlirPDLValue>() - 8usize];
    ["Alignment of MlirPDLValue"][::std::mem::align_of::<MlirPDLValue>() - 8usize];
    ["Offset of field: MlirPDLValue::ptr"][::std::mem::offset_of!(MlirPDLValue, ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPDLResultList {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirPDLResultList"][::std::mem::size_of::<MlirPDLResultList>() - 8usize];
    ["Alignment of MlirPDLResultList"][::std::mem::align_of::<MlirPDLResultList>() - 8usize];
    ["Offset of field: MlirPDLResultList::ptr"][::std::mem::offset_of!(MlirPDLResultList, ptr) - 0usize];
};
unsafe extern "C" {
    pub fn mlirPDLPatternModuleFromModule(op: MlirModule) -> MlirPDLPatternModule;
}
unsafe extern "C" {
    pub fn mlirPDLPatternModuleDestroy(op: MlirPDLPatternModule);
}
unsafe extern "C" {
    pub fn mlirRewritePatternSetFromPDLPatternModule(op: MlirPDLPatternModule) -> MlirRewritePatternSet;
}
unsafe extern "C" {
    #[doc = " Cast the MlirPDLValue to an MlirValue.\n Return a null value if the cast fails, just like llvm::dyn_cast."]
    pub fn mlirPDLValueAsValue(value: MlirPDLValue) -> MlirValue;
}
unsafe extern "C" {
    #[doc = " Cast the MlirPDLValue to an MlirType.\n Return a null value if the cast fails, just like llvm::dyn_cast."]
    pub fn mlirPDLValueAsType(value: MlirPDLValue) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Cast the MlirPDLValue to an MlirOperation.\n Return a null value if the cast fails, just like llvm::dyn_cast."]
    pub fn mlirPDLValueAsOperation(value: MlirPDLValue) -> MlirOperation;
}
unsafe extern "C" {
    #[doc = " Cast the MlirPDLValue to an MlirAttribute.\n Return a null value if the cast fails, just like llvm::dyn_cast."]
    pub fn mlirPDLValueAsAttribute(value: MlirPDLValue) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Push the MlirValue into the given MlirPDLResultList."]
    pub fn mlirPDLResultListPushBackValue(results: MlirPDLResultList, value: MlirValue);
}
unsafe extern "C" {
    #[doc = " Push the MlirType into the given MlirPDLResultList."]
    pub fn mlirPDLResultListPushBackType(results: MlirPDLResultList, value: MlirType);
}
unsafe extern "C" {
    #[doc = " Push the MlirOperation into the given MlirPDLResultList."]
    pub fn mlirPDLResultListPushBackOperation(results: MlirPDLResultList, value: MlirOperation);
}
unsafe extern "C" {
    #[doc = " Push the MlirAttribute into the given MlirPDLResultList."]
    pub fn mlirPDLResultListPushBackAttribute(results: MlirPDLResultList, value: MlirAttribute);
}
#[doc = " This function type is used as callbacks for PDL native rewrite functions.\n Input values can be accessed by `values` with its size `nValues`;\n output values can be added into `results` by `mlirPDLResultListPushBack*`\n APIs. And the return value indicates whether the rewrite succeeds."]
pub type MlirPDLRewriteFunction = ::std::option::Option<
    unsafe extern "C" fn(
        rewriter: MlirPatternRewriter,
        results: MlirPDLResultList,
        nValues: usize,
        values: *mut MlirPDLValue,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult,
>;
unsafe extern "C" {
    #[doc = " Register a rewrite function into the given PDL pattern module.\n `userData` will be provided as an argument to the rewrite function."]
    pub fn mlirPDLPatternModuleRegisterRewriteFunction(
        pdlModule: MlirPDLPatternModule,
        name: MlirStringRef,
        rewriteFn: MlirPDLRewriteFunction,
        userData: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This function type is used as callbacks for PDL native constraint functions.\n Input values can be accessed by `values` with its size `nValues`;\n output values can be added into `results` by `mlirPDLResultListPushBack*`\n APIs. And the return value indicates whether the constraint holds."]
pub type MlirPDLConstraintFunction = ::std::option::Option<
    unsafe extern "C" fn(
        rewriter: MlirPatternRewriter,
        results: MlirPDLResultList,
        nValues: usize,
        values: *mut MlirPDLValue,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult,
>;
unsafe extern "C" {
    #[doc = " Register a constraint function into the given PDL pattern module.\n `userData` will be provided as an argument to the constraint function."]
    pub fn mlirPDLPatternModuleRegisterConstraintFunction(
        pdlModule: MlirPDLPatternModule,
        name: MlirStringRef,
        constraintFn: MlirPDLConstraintFunction,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsPasses();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsBubbleDownMemorySpaceCasts() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsBubbleDownMemorySpaceCasts();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsCSE() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsCSE();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsCanonicalizer() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsCanonicalizer();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsCompositeFixedPointPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsCompositeFixedPointPass();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsControlFlowSink() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsControlFlowSink();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsGenerateRuntimeVerification() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsGenerateRuntimeVerification();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsInliner() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsInliner();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsLocationSnapshot() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsLocationSnapshot();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsLoopInvariantCodeMotion() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsLoopInvariantCodeMotion();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsLoopInvariantSubsetHoisting() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsLoopInvariantSubsetHoisting();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsMem2Reg() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsMem2Reg();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsPrintIRPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsPrintIRPass();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsPrintOpStats() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsPrintOpStats();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsRemoveDeadValues() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsRemoveDeadValues();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsSCCP() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsSCCP();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsSROA() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsSROA();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsStripDebugInfo() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsStripDebugInfo();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsSymbolDCE() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsSymbolDCE();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsSymbolPrivatize() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsSymbolPrivatize();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsTopologicalSort() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsTopologicalSort();
}
unsafe extern "C" {
    pub fn mlirCreateTransformsViewOpGraph() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTransformsViewOpGraph();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__amdgpu__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirTypeIsAAMDGPUTDMBaseType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMBaseTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMBaseTypeGet(ctx: MlirContext, elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMBaseTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAAMDGPUTDMDescriptorType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMDescriptorTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMDescriptorTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMDescriptorTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAAMDGPUTDMGatherBaseType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMGatherBaseTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMGatherBaseTypeGet(ctx: MlirContext, elementType: MlirType, indexType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirAMDGPUTDMGatherBaseTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirRegisterPasses();
}
unsafe extern "C" {
    pub fn mlirCreateAmdgpuEmulateAtomicsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAmdgpuEmulateAtomicsPass();
}
unsafe extern "C" {
    pub fn mlirCreateAmdgpuFoldMemRefOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAmdgpuFoldMemRefOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateAmdgpuMaskedloadToLoadPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAmdgpuMaskedloadToLoadPass();
}
unsafe extern "C" {
    pub fn mlirCreateAmdgpuResolveStridedMetadataPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAmdgpuResolveStridedMetadataPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__arith__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateArithEmulateUnsupportedFloats() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterArithEmulateUnsupportedFloats();
}
unsafe extern "C" {
    pub fn mlirCreateArithEmulateWideInt() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterArithEmulateWideInt();
}
unsafe extern "C" {
    pub fn mlirCreateArithExpandOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterArithExpandOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateArithIntRangeNarrowing() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterArithIntRangeNarrowing();
}
unsafe extern "C" {
    pub fn mlirCreateArithIntRangeOpts() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterArithIntRangeOpts();
}
unsafe extern "C" {
    pub fn mlirCreateArithUnsignedWhenEquivalentPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterArithUnsignedWhenEquivalentPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__async__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncPasses();
}
unsafe extern "C" {
    pub fn mlirCreateAsyncAsyncFuncToAsyncRuntimePass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncAsyncFuncToAsyncRuntimePass();
}
unsafe extern "C" {
    pub fn mlirCreateAsyncAsyncParallelForPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncAsyncParallelForPass();
}
unsafe extern "C" {
    pub fn mlirCreateAsyncAsyncRuntimePolicyBasedRefCountingPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncAsyncRuntimePolicyBasedRefCountingPass();
}
unsafe extern "C" {
    pub fn mlirCreateAsyncAsyncRuntimeRefCountingOptPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncAsyncRuntimeRefCountingOptPass();
}
unsafe extern "C" {
    pub fn mlirCreateAsyncAsyncRuntimeRefCountingPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncAsyncRuntimeRefCountingPass();
}
unsafe extern "C" {
    pub fn mlirCreateAsyncAsyncToAsyncRuntimePass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterAsyncAsyncToAsyncRuntimePass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__cf__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__emitc__() -> MlirDialectHandle;
}
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_EQ: MlirEmitCCmpPredicate = 0;
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_NE: MlirEmitCCmpPredicate = 1;
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_LT: MlirEmitCCmpPredicate = 2;
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_LE: MlirEmitCCmpPredicate = 3;
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_GT: MlirEmitCCmpPredicate = 4;
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_GE: MlirEmitCCmpPredicate = 5;
pub const MlirEmitCCmpPredicate_MLIR_EMITC_CMP_PREDICATE_THREE_WAY: MlirEmitCCmpPredicate = 6;
pub type MlirEmitCCmpPredicate = u64;
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCArrayType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCArrayTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCArrayTypeGet(nDims: isize, shape: *mut i64, elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCArrayTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCLValueType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCLValueTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCLValueTypeGet(valueType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCLValueTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCOpaqueType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueTypeGet(ctx: MlirContext, value: MlirStringRef) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCPointerType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCPointerTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCPointerTypeGet(pointee: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCPointerTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCPtrDiffTType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCPtrDiffTTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCPtrDiffTTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCPtrDiffTTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCSignedSizeTType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCSignedSizeTTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCSignedSizeTTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCSignedSizeTTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAEmitCSizeTType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCSizeTTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirEmitCSizeTTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirEmitCSizeTTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirAttributeIsAEmitCCmpPredicate(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCCmpPredicateAttrGet(ctx: MlirContext, val: MlirEmitCCmpPredicate) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirEmitCCmpPredicateAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirEmitCCmpPredicateAttrGetValue(attr: MlirAttribute) -> MlirEmitCCmpPredicate;
}
unsafe extern "C" {
    pub fn mlirEmitCCmpPredicateAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirAttributeIsAEmitCOpaque(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirEmitCOpaqueAttrGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirCreateFormExpressionsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterFormExpressionsPass();
}
unsafe extern "C" {
    pub fn mlirCreateWrapFuncInClassPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterWrapFuncInClassPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__func__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Sets the argument attribute 'name' of an argument at index 'pos'.\n Asserts that the operation is a FuncOp."]
    pub fn mlirFuncSetArgAttr(op: MlirOperation, pos: isize, name: MlirStringRef, attr: MlirAttribute);
}
unsafe extern "C" {
    pub fn mlirFuncSetResultAttr(op: MlirOperation, pos: isize, name: MlirStringRef, attr: MlirAttribute);
}
unsafe extern "C" {
    pub fn mlirCreateDuplicateFunctionEliminationPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterDuplicateFunctionEliminationPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__gpu__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirTypeIsAGPUAsyncTokenType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirGPUAsyncTokenTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirGPUAsyncTokenTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirAttributeIsAGPUObjectAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGet(
        mlirCtx: MlirContext,
        target: MlirAttribute,
        format: u32,
        objectStrRef: MlirStringRef,
        mlirObjectProps: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetWithKernels(
        mlirCtx: MlirContext,
        target: MlirAttribute,
        format: u32,
        objectStrRef: MlirStringRef,
        mlirObjectProps: MlirAttribute,
        mlirKernelsAttr: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetTarget(mlirObjectAttr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetFormat(mlirObjectAttr: MlirAttribute) -> u32;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetObject(mlirObjectAttr: MlirAttribute) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrHasProperties(mlirObjectAttr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetProperties(mlirObjectAttr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrHasKernels(mlirObjectAttr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    pub fn mlirGPUObjectAttrGetKernels(mlirObjectAttr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUPasses();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuAsyncRegionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuAsyncRegionPass();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuDecomposeMemrefsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuDecomposeMemrefsPass();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuEliminateBarriers() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuEliminateBarriers();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuKernelOutliningPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuKernelOutliningPass();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuLaunchSinkIndexComputationsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuLaunchSinkIndexComputationsPass();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuMapParallelLoopsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuMapParallelLoopsPass();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuModuleToBinaryPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuModuleToBinaryPass();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuNVVMAttachTarget() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuNVVMAttachTarget();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuROCDLAttachTarget() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuROCDLAttachTarget();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuSPIRVAttachTarget() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuSPIRVAttachTarget();
}
unsafe extern "C" {
    pub fn mlirCreateGPUGpuXeVMAttachTarget() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterGPUGpuXeVMAttachTarget();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__index__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__irdl__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Loads all IRDL dialects in the provided module, registering the dialects in\n the module's associated context."]
    pub fn mlirLoadIRDLDialects(module: MlirModule) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn mlirIRDLVariadicityAttrGet(ctx: MlirContext, value: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirIRDLVariadicityAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirIRDLVariadicityArrayAttrGet(
        ctx: MlirContext,
        nValues: isize,
        values: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirIRDLVariadicityArrayAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Apply the special region builder for the builtin named Linalg op.\n Assert that `mlirOp` is a builtin named Linalg op."]
    pub fn mlirLinalgFillBuiltinNamedOpRegion(mlirOp: MlirOperation);
}
unsafe extern "C" {
    pub fn mlirLinalgIsAContractionOp(op: MlirOperation) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLinalgContractionDimensions {
    pub batch: MlirAttribute,
    pub m: MlirAttribute,
    pub n: MlirAttribute,
    pub k: MlirAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirLinalgContractionDimensions"][::std::mem::size_of::<MlirLinalgContractionDimensions>() - 32usize];
    ["Alignment of MlirLinalgContractionDimensions"]
        [::std::mem::align_of::<MlirLinalgContractionDimensions>() - 8usize];
    ["Offset of field: MlirLinalgContractionDimensions::batch"]
        [::std::mem::offset_of!(MlirLinalgContractionDimensions, batch) - 0usize];
    ["Offset of field: MlirLinalgContractionDimensions::m"]
        [::std::mem::offset_of!(MlirLinalgContractionDimensions, m) - 8usize];
    ["Offset of field: MlirLinalgContractionDimensions::n"]
        [::std::mem::offset_of!(MlirLinalgContractionDimensions, n) - 16usize];
    ["Offset of field: MlirLinalgContractionDimensions::k"]
        [::std::mem::offset_of!(MlirLinalgContractionDimensions, k) - 24usize];
};
unsafe extern "C" {
    pub fn mlirLinalgInferContractionDimensions(op: MlirOperation) -> MlirLinalgContractionDimensions;
}
unsafe extern "C" {
    pub fn mlirLinalgInferContractionDimensionsFromMaps(
        indexingMaps: *const MlirAffineMap,
        numMaps: usize,
    ) -> MlirLinalgContractionDimensions;
}
unsafe extern "C" {
    pub fn mlirLinalgIsAConvolutionOp(op: MlirOperation) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLinalgConvolutionDimensions {
    pub batch: MlirAttribute,
    pub outputImage: MlirAttribute,
    pub outputChannel: MlirAttribute,
    pub filterLoop: MlirAttribute,
    pub inputChannel: MlirAttribute,
    pub depth: MlirAttribute,
    pub strides: MlirAttribute,
    pub dilations: MlirAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirLinalgConvolutionDimensions"][::std::mem::size_of::<MlirLinalgConvolutionDimensions>() - 64usize];
    ["Alignment of MlirLinalgConvolutionDimensions"]
        [::std::mem::align_of::<MlirLinalgConvolutionDimensions>() - 8usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::batch"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, batch) - 0usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::outputImage"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, outputImage) - 8usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::outputChannel"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, outputChannel) - 16usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::filterLoop"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, filterLoop) - 24usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::inputChannel"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, inputChannel) - 32usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::depth"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, depth) - 40usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::strides"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, strides) - 48usize];
    ["Offset of field: MlirLinalgConvolutionDimensions::dilations"]
        [::std::mem::offset_of!(MlirLinalgConvolutionDimensions, dilations) - 56usize];
};
unsafe extern "C" {
    pub fn mlirLinalgInferConvolutionDimensions(op: MlirOperation) -> MlirLinalgConvolutionDimensions;
}
unsafe extern "C" {
    pub fn mlirLinalgGetIndexingMapsAttribute(op: MlirOperation) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__linalg__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgPasses();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgConvertElementwiseToLinalgPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgConvertElementwiseToLinalgPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgConvertLinalgToAffineLoopsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgConvertLinalgToAffineLoopsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgConvertLinalgToLoopsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgConvertLinalgToLoopsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgConvertLinalgToParallelLoopsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgConvertLinalgToParallelLoopsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgBlockPackMatmul() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgBlockPackMatmul();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgElementwiseOpFusionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgElementwiseOpFusionPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgFoldIntoElementwisePass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgFoldIntoElementwisePass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgFoldUnitExtentDimsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgFoldUnitExtentDimsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgGeneralizeNamedOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgGeneralizeNamedOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgInlineScalarOperandsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgInlineScalarOperandsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgMorphOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgMorphOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgLinalgSpecializeGenericOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgLinalgSpecializeGenericOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateLinalgSimplifyDepthwiseConvPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLinalgSimplifyDepthwiseConvPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__llvm__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Creates an llvm.ptr type."]
    pub fn mlirLLVMPointerTypeGet(ctx: MlirContext, addressSpace: ::std::os::raw::c_uint) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirLLVMPointerTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirLLVMPointerTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the type is an LLVM dialect pointer type."]
    pub fn mlirTypeIsALLVMPointerType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns address space of llvm.ptr"]
    pub fn mlirLLVMPointerTypeGetAddressSpace(pointerType: MlirType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Creates an llmv.void type."]
    pub fn mlirLLVMVoidTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirLLVMVoidTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates an llvm.array type."]
    pub fn mlirLLVMArrayTypeGet(elementType: MlirType, numElements: ::std::os::raw::c_uint) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirLLVMArrayTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the element type of the llvm.array type."]
    pub fn mlirLLVMArrayTypeGetElementType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates an llvm.func type."]
    pub fn mlirLLVMFunctionTypeGet(
        resultType: MlirType,
        nArgumentTypes: isize,
        argumentTypes: *const MlirType,
        isVarArg: bool,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirLLVMFunctionTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of input types."]
    pub fn mlirLLVMFunctionTypeGetNumInputs(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the pos-th input type."]
    pub fn mlirLLVMFunctionTypeGetInput(type_: MlirType, pos: isize) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the return type of the function type."]
    pub fn mlirLLVMFunctionTypeGetReturnType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the type is an LLVM dialect struct type."]
    pub fn mlirTypeIsALLVMStructType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirLLVMStructTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirLLVMStructTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the type is a literal (unnamed) LLVM struct type."]
    pub fn mlirLLVMStructTypeIsLiteral(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of fields in the struct. Asserts if the struct is opaque\n or not yet initialized."]
    pub fn mlirLLVMStructTypeGetNumElementTypes(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the `positions`-th field of the struct. Asserts if the struct is\n opaque, not yet initialized or if the position is out of range."]
    pub fn mlirLLVMStructTypeGetElementType(type_: MlirType, position: isize) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the struct is packed."]
    pub fn mlirLLVMStructTypeIsPacked(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the identifier of the identified struct. Asserts that the struct is\n identified, i.e., not literal."]
    pub fn mlirLLVMStructTypeGetIdentifier(type_: MlirType) -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns `true` is the struct is explicitly opaque (will not have a body) or\n uninitialized (will eventually have a body)."]
    pub fn mlirLLVMStructTypeIsOpaque(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an LLVM literal (unnamed) struct type. This may assert if the fields\n have types not compatible with the LLVM dialect. For a graceful failure, use\n the checked version."]
    pub fn mlirLLVMStructTypeLiteralGet(
        ctx: MlirContext,
        nFieldTypes: isize,
        fieldTypes: *const MlirType,
        isPacked: bool,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates an LLVM literal (unnamed) struct type if possible. Emits a\n diagnostic at the given location and returns null otherwise."]
    pub fn mlirLLVMStructTypeLiteralGetChecked(
        loc: MlirLocation,
        nFieldTypes: isize,
        fieldTypes: *const MlirType,
        isPacked: bool,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates an LLVM identified struct type with no body. If a struct type with\n this name already exists in the context, returns that type. Use\n mlirLLVMStructTypeIdentifiedNewGet to create a fresh struct type,\n potentially renaming it. The body should be set separatelty by calling\n mlirLLVMStructTypeSetBody, if it isn't set already."]
    pub fn mlirLLVMStructTypeIdentifiedGet(ctx: MlirContext, name: MlirStringRef) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Creates an LLVM identified struct type with no body and a name starting with\n the given prefix. If a struct with the exact name as the given prefix\n already exists, appends an unspecified suffix to the name so that the name\n is unique in context."]
    pub fn mlirLLVMStructTypeIdentifiedNewGet(
        ctx: MlirContext,
        name: MlirStringRef,
        nFieldTypes: isize,
        fieldTypes: *const MlirType,
        isPacked: bool,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirLLVMStructTypeOpaqueGet(ctx: MlirContext, name: MlirStringRef) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Sets the body of the identified struct if it hasn't been set yet. Returns\n whether the operation was successful."]
    pub fn mlirLLVMStructTypeSetBody(
        structType: MlirType,
        nFieldTypes: isize,
        fieldTypes: *const MlirType,
        isPacked: bool,
    ) -> MlirLogicalResult;
}
pub const MlirLLVMCConv_MlirLLVMCConvC: MlirLLVMCConv = 0;
pub const MlirLLVMCConv_MlirLLVMCConvFast: MlirLLVMCConv = 8;
pub const MlirLLVMCConv_MlirLLVMCConvCold: MlirLLVMCConv = 9;
pub const MlirLLVMCConv_MlirLLVMCConvGHC: MlirLLVMCConv = 10;
pub const MlirLLVMCConv_MlirLLVMCConvHiPE: MlirLLVMCConv = 11;
pub const MlirLLVMCConv_MlirLLVMCConvAnyReg: MlirLLVMCConv = 13;
pub const MlirLLVMCConv_MlirLLVMCConvPreserveMost: MlirLLVMCConv = 14;
pub const MlirLLVMCConv_MlirLLVMCConvPreserveAll: MlirLLVMCConv = 15;
pub const MlirLLVMCConv_MlirLLVMCConvSwift: MlirLLVMCConv = 16;
pub const MlirLLVMCConv_MlirLLVMCConvCXX_FAST_TLS: MlirLLVMCConv = 17;
pub const MlirLLVMCConv_MlirLLVMCConvTail: MlirLLVMCConv = 18;
pub const MlirLLVMCConv_MlirLLVMCConvCFGuard_Check: MlirLLVMCConv = 19;
pub const MlirLLVMCConv_MlirLLVMCConvSwiftTail: MlirLLVMCConv = 20;
pub const MlirLLVMCConv_MlirLLVMCConvX86_StdCall: MlirLLVMCConv = 64;
pub const MlirLLVMCConv_MlirLLVMCConvX86_FastCall: MlirLLVMCConv = 65;
pub const MlirLLVMCConv_MlirLLVMCConvARM_APCS: MlirLLVMCConv = 66;
pub const MlirLLVMCConv_MlirLLVMCConvARM_AAPCS: MlirLLVMCConv = 67;
pub const MlirLLVMCConv_MlirLLVMCConvARM_AAPCS_VFP: MlirLLVMCConv = 68;
pub const MlirLLVMCConv_MlirLLVMCConvMSP430_INTR: MlirLLVMCConv = 69;
pub const MlirLLVMCConv_MlirLLVMCConvX86_ThisCall: MlirLLVMCConv = 70;
pub const MlirLLVMCConv_MlirLLVMCConvPTX_Kernel: MlirLLVMCConv = 71;
pub const MlirLLVMCConv_MlirLLVMCConvPTX_Device: MlirLLVMCConv = 72;
pub const MlirLLVMCConv_MlirLLVMCConvSPIR_FUNC: MlirLLVMCConv = 75;
pub const MlirLLVMCConv_MlirLLVMCConvSPIR_KERNEL: MlirLLVMCConv = 76;
pub const MlirLLVMCConv_MlirLLVMCConvIntel_OCL_BI: MlirLLVMCConv = 77;
pub const MlirLLVMCConv_MlirLLVMCConvX86_64_SysV: MlirLLVMCConv = 78;
pub const MlirLLVMCConv_MlirLLVMCConvWin64: MlirLLVMCConv = 79;
pub const MlirLLVMCConv_MlirLLVMCConvX86_VectorCall: MlirLLVMCConv = 80;
pub const MlirLLVMCConv_MlirLLVMCConvDUMMY_HHVM: MlirLLVMCConv = 81;
pub const MlirLLVMCConv_MlirLLVMCConvDUMMY_HHVM_C: MlirLLVMCConv = 82;
pub const MlirLLVMCConv_MlirLLVMCConvX86_INTR: MlirLLVMCConv = 83;
pub const MlirLLVMCConv_MlirLLVMCConvAVR_INTR: MlirLLVMCConv = 84;
pub const MlirLLVMCConv_MlirLLVMCConvAVR_BUILTIN: MlirLLVMCConv = 86;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_VS: MlirLLVMCConv = 87;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_GS: MlirLLVMCConv = 88;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_CS: MlirLLVMCConv = 90;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_KERNEL: MlirLLVMCConv = 91;
pub const MlirLLVMCConv_MlirLLVMCConvX86_RegCall: MlirLLVMCConv = 92;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_HS: MlirLLVMCConv = 93;
pub const MlirLLVMCConv_MlirLLVMCConvMSP430_BUILTIN: MlirLLVMCConv = 94;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_LS: MlirLLVMCConv = 95;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_ES: MlirLLVMCConv = 96;
pub const MlirLLVMCConv_MlirLLVMCConvAArch64_VectorCall: MlirLLVMCConv = 97;
pub const MlirLLVMCConv_MlirLLVMCConvAArch64_SVE_VectorCall: MlirLLVMCConv = 98;
pub const MlirLLVMCConv_MlirLLVMCConvWASM_EmscriptenInvoke: MlirLLVMCConv = 99;
pub const MlirLLVMCConv_MlirLLVMCConvAMDGPU_Gfx: MlirLLVMCConv = 100;
pub const MlirLLVMCConv_MlirLLVMCConvM68k_INTR: MlirLLVMCConv = 101;
pub type MlirLLVMCConv = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Creates a LLVM CConv attribute."]
    pub fn mlirLLVMCConvAttrGet(ctx: MlirContext, cconv: MlirLLVMCConv) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMCConvAttrGetName() -> MlirStringRef;
}
pub const MlirLLVMComdat_MlirLLVMComdatAny: MlirLLVMComdat = 0;
pub const MlirLLVMComdat_MlirLLVMComdatExactMatch: MlirLLVMComdat = 1;
pub const MlirLLVMComdat_MlirLLVMComdatLargest: MlirLLVMComdat = 2;
pub const MlirLLVMComdat_MlirLLVMComdatNoDeduplicate: MlirLLVMComdat = 3;
pub const MlirLLVMComdat_MlirLLVMComdatSameSize: MlirLLVMComdat = 4;
pub type MlirLLVMComdat = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Creates a LLVM Comdat attribute."]
    pub fn mlirLLVMComdatAttrGet(ctx: MlirContext, comdat: MlirLLVMComdat) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMComdatAttrGetName() -> MlirStringRef;
}
pub const MlirLLVMLinkage_MlirLLVMLinkageExternal: MlirLLVMLinkage = 0;
pub const MlirLLVMLinkage_MlirLLVMLinkageAvailableExternally: MlirLLVMLinkage = 1;
pub const MlirLLVMLinkage_MlirLLVMLinkageLinkonce: MlirLLVMLinkage = 2;
pub const MlirLLVMLinkage_MlirLLVMLinkageLinkonceODR: MlirLLVMLinkage = 3;
pub const MlirLLVMLinkage_MlirLLVMLinkageWeak: MlirLLVMLinkage = 4;
pub const MlirLLVMLinkage_MlirLLVMLinkageWeakODR: MlirLLVMLinkage = 5;
pub const MlirLLVMLinkage_MlirLLVMLinkageAppending: MlirLLVMLinkage = 6;
pub const MlirLLVMLinkage_MlirLLVMLinkageInternal: MlirLLVMLinkage = 7;
pub const MlirLLVMLinkage_MlirLLVMLinkagePrivate: MlirLLVMLinkage = 8;
pub const MlirLLVMLinkage_MlirLLVMLinkageExternWeak: MlirLLVMLinkage = 9;
pub const MlirLLVMLinkage_MlirLLVMLinkageCommon: MlirLLVMLinkage = 10;
pub type MlirLLVMLinkage = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Creates a LLVM Linkage attribute."]
    pub fn mlirLLVMLinkageAttrGet(ctx: MlirContext, linkage: MlirLLVMLinkage) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMLinkageAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DINullType attribute."]
    pub fn mlirLLVMDINullTypeAttrGet(ctx: MlirContext) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDINullTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIExpressionElem attribute."]
    pub fn mlirLLVMDIExpressionElemAttrGet(
        ctx: MlirContext,
        opcode: ::std::os::raw::c_uint,
        nArguments: isize,
        arguments: *const u64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIExpressionElemAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIExpression attribute."]
    pub fn mlirLLVMDIExpressionAttrGet(
        ctx: MlirContext,
        nOperations: isize,
        operations: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIExpressionAttrGetName() -> MlirStringRef;
}
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingAddress: MlirLLVMTypeEncoding = 1;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingBoolean: MlirLLVMTypeEncoding = 2;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingComplexFloat: MlirLLVMTypeEncoding = 49;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingFloatT: MlirLLVMTypeEncoding = 4;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingSigned: MlirLLVMTypeEncoding = 5;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingSignedChar: MlirLLVMTypeEncoding = 6;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingUnsigned: MlirLLVMTypeEncoding = 7;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingUnsignedChar: MlirLLVMTypeEncoding = 8;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingImaginaryFloat: MlirLLVMTypeEncoding = 9;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingPackedDecimal: MlirLLVMTypeEncoding = 10;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingNumericString: MlirLLVMTypeEncoding = 11;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingEdited: MlirLLVMTypeEncoding = 12;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingSignedFixed: MlirLLVMTypeEncoding = 13;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingUnsignedFixed: MlirLLVMTypeEncoding = 14;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingDecimalFloat: MlirLLVMTypeEncoding = 15;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingUTF: MlirLLVMTypeEncoding = 16;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingUCS: MlirLLVMTypeEncoding = 17;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingASCII: MlirLLVMTypeEncoding = 18;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingLoUser: MlirLLVMTypeEncoding = 128;
pub const MlirLLVMTypeEncoding_MlirLLVMTypeEncodingHiUser: MlirLLVMTypeEncoding = 255;
pub type MlirLLVMTypeEncoding = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Creates a LLVM DIBasicType attribute."]
    pub fn mlirLLVMDIBasicTypeAttrGet(
        ctx: MlirContext,
        tag: ::std::os::raw::c_uint,
        name: MlirAttribute,
        sizeInBits: u64,
        encoding: MlirLLVMTypeEncoding,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIBasicTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a self-referencing LLVM DICompositeType attribute."]
    pub fn mlirLLVMDICompositeTypeAttrGetRecSelf(recId: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DICompositeType attribute."]
    pub fn mlirLLVMDICompositeTypeAttrGet(
        ctx: MlirContext,
        recId: MlirAttribute,
        isRecSelf: bool,
        tag: ::std::os::raw::c_uint,
        name: MlirAttribute,
        file: MlirAttribute,
        line: u32,
        scope: MlirAttribute,
        baseType: MlirAttribute,
        flags: i64,
        sizeInBits: u64,
        alignInBits: u64,
        nElements: isize,
        elements: *const MlirAttribute,
        dataLocation: MlirAttribute,
        rank: MlirAttribute,
        allocated: MlirAttribute,
        associated: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDICompositeTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIDerivedType attribute.  Note that `dwarfAddressSpace` is an\n optional field, where `MLIR_CAPI_DWARF_ADDRESS_SPACE_NULL` indicates null\n and non-negative values indicate a value present."]
    pub fn mlirLLVMDIDerivedTypeAttrGet(
        ctx: MlirContext,
        tag: ::std::os::raw::c_uint,
        name: MlirAttribute,
        baseType: MlirAttribute,
        sizeInBits: u64,
        alignInBits: u32,
        offsetInBits: u64,
        dwarfAddressSpace: i64,
        extraData: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIDerivedTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirLLVMDIStringTypeAttrGet(
        ctx: MlirContext,
        tag: ::std::os::raw::c_uint,
        name: MlirAttribute,
        sizeInBits: u64,
        alignInBits: u32,
        stringLength: MlirAttribute,
        stringLengthExp: MlirAttribute,
        stringLocationExp: MlirAttribute,
        encoding: MlirLLVMTypeEncoding,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIStringTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Gets the base type from a LLVM DIDerivedType attribute."]
    pub fn mlirLLVMDIDerivedTypeAttrGetBaseType(diDerivedType: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIFileAttr attribute."]
    pub fn mlirLLVMDIFileAttrGet(ctx: MlirContext, name: MlirAttribute, directory: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIFileAttrGetName() -> MlirStringRef;
}
pub const MlirLLVMDIEmissionKind_MlirLLVMDIEmissionKindNone: MlirLLVMDIEmissionKind = 0;
pub const MlirLLVMDIEmissionKind_MlirLLVMDIEmissionKindFull: MlirLLVMDIEmissionKind = 1;
pub const MlirLLVMDIEmissionKind_MlirLLVMDIEmissionKindLineTablesOnly: MlirLLVMDIEmissionKind = 2;
pub const MlirLLVMDIEmissionKind_MlirLLVMDIEmissionKindDebugDirectivesOnly: MlirLLVMDIEmissionKind = 3;
pub type MlirLLVMDIEmissionKind = ::std::os::raw::c_uint;
pub const MlirLLVMDINameTableKind_MlirLLVMDINameTableKindDefault: MlirLLVMDINameTableKind = 0;
pub const MlirLLVMDINameTableKind_MlirLLVMDINameTableKindGNU: MlirLLVMDINameTableKind = 1;
pub const MlirLLVMDINameTableKind_MlirLLVMDINameTableKindNone: MlirLLVMDINameTableKind = 2;
pub const MlirLLVMDINameTableKind_MlirLLVMDINameTableKindApple: MlirLLVMDINameTableKind = 3;
pub type MlirLLVMDINameTableKind = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Creates a LLVM DICompileUnit attribute."]
    pub fn mlirLLVMDICompileUnitAttrGet(
        ctx: MlirContext,
        id: MlirAttribute,
        sourceLanguage: ::std::os::raw::c_uint,
        file: MlirAttribute,
        producer: MlirAttribute,
        isOptimized: bool,
        emissionKind: MlirLLVMDIEmissionKind,
        nameTableKind: MlirLLVMDINameTableKind,
        splitDebugFilename: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDICompileUnitAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIFlags attribute."]
    pub fn mlirLLVMDIFlagsAttrGet(ctx: MlirContext, value: u64) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIFlagsAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DILexicalBlock attribute."]
    pub fn mlirLLVMDILexicalBlockAttrGet(
        ctx: MlirContext,
        scope: MlirAttribute,
        file: MlirAttribute,
        line: ::std::os::raw::c_uint,
        column: ::std::os::raw::c_uint,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDILexicalBlockAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DILexicalBlockFile attribute."]
    pub fn mlirLLVMDILexicalBlockFileAttrGet(
        ctx: MlirContext,
        scope: MlirAttribute,
        file: MlirAttribute,
        discriminator: ::std::os::raw::c_uint,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDILexicalBlockFileAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DILocalVariableAttr attribute."]
    pub fn mlirLLVMDILocalVariableAttrGet(
        ctx: MlirContext,
        scope: MlirAttribute,
        name: MlirAttribute,
        diFile: MlirAttribute,
        line: ::std::os::raw::c_uint,
        arg: ::std::os::raw::c_uint,
        alignInBits: ::std::os::raw::c_uint,
        diType: MlirAttribute,
        flags: i64,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDILocalVariableAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a self-referencing LLVM DISubprogramAttr attribute."]
    pub fn mlirLLVMDISubprogramAttrGetRecSelf(recId: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DISubprogramAttr attribute."]
    pub fn mlirLLVMDISubprogramAttrGet(
        ctx: MlirContext,
        recId: MlirAttribute,
        isRecSelf: bool,
        id: MlirAttribute,
        compileUnit: MlirAttribute,
        scope: MlirAttribute,
        name: MlirAttribute,
        linkageName: MlirAttribute,
        file: MlirAttribute,
        line: ::std::os::raw::c_uint,
        scopeLine: ::std::os::raw::c_uint,
        subprogramFlags: u64,
        type_: MlirAttribute,
        nRetainedNodes: isize,
        retainedNodes: *const MlirAttribute,
        nAnnotations: isize,
        annotations: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDISubprogramAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIAnnotation attribute."]
    pub fn mlirLLVMDIAnnotationAttrGet(ctx: MlirContext, name: MlirAttribute, value: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIAnnotationAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Gets the scope from this DISubprogramAttr."]
    pub fn mlirLLVMDISubprogramAttrGetScope(diSubprogram: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Gets the line from this DISubprogramAttr."]
    pub fn mlirLLVMDISubprogramAttrGetLine(diSubprogram: MlirAttribute) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Gets the scope line from this DISubprogram."]
    pub fn mlirLLVMDISubprogramAttrGetScopeLine(diSubprogram: MlirAttribute) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Gets the compile unit from this DISubprogram."]
    pub fn mlirLLVMDISubprogramAttrGetCompileUnit(diSubprogram: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Gets the file from this DISubprogramAttr."]
    pub fn mlirLLVMDISubprogramAttrGetFile(diSubprogram: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Gets the type from this DISubprogramAttr."]
    pub fn mlirLLVMDISubprogramAttrGetType(diSubprogram: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DISubroutineTypeAttr attribute."]
    pub fn mlirLLVMDISubroutineTypeAttrGet(
        ctx: MlirContext,
        callingConvention: ::std::os::raw::c_uint,
        nTypes: isize,
        types: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDISubroutineTypeAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIModuleAttr attribute."]
    pub fn mlirLLVMDIModuleAttrGet(
        ctx: MlirContext,
        file: MlirAttribute,
        scope: MlirAttribute,
        name: MlirAttribute,
        configMacros: MlirAttribute,
        includePath: MlirAttribute,
        apinotes: MlirAttribute,
        line: ::std::os::raw::c_uint,
        isDecl: bool,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIModuleAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a LLVM DIImportedEntityAttr attribute."]
    pub fn mlirLLVMDIImportedEntityAttrGet(
        ctx: MlirContext,
        tag: ::std::os::raw::c_uint,
        scope: MlirAttribute,
        entity: MlirAttribute,
        file: MlirAttribute,
        line: ::std::os::raw::c_uint,
        name: MlirAttribute,
        nElements: isize,
        elements: *const MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirLLVMDIImportedEntityAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Gets the scope of this DIModuleAttr."]
    pub fn mlirLLVMDIModuleAttrGetScope(diModule: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirCreateDIScopeForLLVMFuncOpPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterDIScopeForLLVMFuncOpPass();
}
unsafe extern "C" {
    pub fn mlirCreateLLVMAddComdats() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLLVMAddComdats();
}
unsafe extern "C" {
    pub fn mlirCreateLLVMLegalizeForExportPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLLVMLegalizeForExportPass();
}
unsafe extern "C" {
    pub fn mlirCreateLLVMRequestCWrappersPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLLVMRequestCWrappersPass();
}
unsafe extern "C" {
    pub fn mlirCreateLLVMUseDefaultVisibilityPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLLVMUseDefaultVisibilityPass();
}
unsafe extern "C" {
    pub fn mlirCreateNVVMOptimizeForTargetPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterNVVMOptimizeForTargetPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__math__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateMathExpandOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterMathExpandOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateMathExtendToSupportedTypes() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterMathExtendToSupportedTypes();
}
unsafe extern "C" {
    pub fn mlirCreateMathSincosFusionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterMathSincosFusionPass();
}
unsafe extern "C" {
    pub fn mlirCreateMathUpliftToFMA() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterMathUpliftToFMA();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__memref__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateExpandOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterExpandOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateExpandReallocPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterExpandReallocPass();
}
unsafe extern "C" {
    pub fn mlirCreateExpandStridedMetadataPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterExpandStridedMetadataPass();
}
unsafe extern "C" {
    pub fn mlirCreateFlattenMemrefsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterFlattenMemrefsPass();
}
unsafe extern "C" {
    pub fn mlirCreateFoldMemRefAliasOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterFoldMemRefAliasOpsPass();
}
unsafe extern "C" {
    pub fn mlirCreateMemRefEmulateWideInt() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterMemRefEmulateWideInt();
}
unsafe extern "C" {
    pub fn mlirCreateNormalizeMemRefsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterNormalizeMemRefsPass();
}
unsafe extern "C" {
    pub fn mlirCreateReifyResultShapesPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterReifyResultShapesPass();
}
unsafe extern "C" {
    pub fn mlirCreateResolveRankedShapeTypeResultDimsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterResolveRankedShapeTypeResultDimsPass();
}
unsafe extern "C" {
    pub fn mlirCreateResolveShapedTypeResultDimsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterResolveShapedTypeResultDimsPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__ml_program__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateMLProgramPipelineGlobalsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterMLProgramPipelineGlobalsPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__nvgpu__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirTypeIsANVGPUTensorMapDescriptorType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirNVGPUTensorMapDescriptorTypeGet(
        ctx: MlirContext,
        tensorMemrefType: MlirType,
        swizzle: ::std::os::raw::c_int,
        l2promo: ::std::os::raw::c_int,
        oobFill: ::std::os::raw::c_int,
        interleave: ::std::os::raw::c_int,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirNVGPUTensorMapDescriptorTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirCreateOptimizeSharedMemory() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterOptimizeSharedMemory();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__nvvm__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__pdl__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirTypeIsAPDLType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirTypeIsAPDLAttributeType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirPDLAttributeTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirPDLAttributeTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirPDLAttributeTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAPDLOperationType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirPDLOperationTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirPDLOperationTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirPDLOperationTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAPDLRangeType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirPDLRangeTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirPDLRangeTypeGet(elementType: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirPDLRangeTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirPDLRangeTypeGetElementType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTypeIsAPDLTypeType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirPDLTypeTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirPDLTypeTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirPDLTypeTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsAPDLValueType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirPDLValueTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirPDLValueTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirPDLValueTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__quant__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is a quantization dialect type."]
    pub fn mlirTypeIsAQuantizedType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the bit flag used to indicate signedness of a quantized type."]
    pub fn mlirQuantizedTypeGetSignedFlag() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Returns the minimum possible value stored by a quantized type."]
    pub fn mlirQuantizedTypeGetDefaultMinimumForInteger(isSigned: bool, integralWidth: ::std::os::raw::c_uint) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the maximum possible value stored by a quantized type."]
    pub fn mlirQuantizedTypeGetDefaultMaximumForInteger(isSigned: bool, integralWidth: ::std::os::raw::c_uint) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the original type approximated by the given quantized type."]
    pub fn mlirQuantizedTypeGetExpressedType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Gets the flags associated with the given quantized type."]
    pub fn mlirQuantizedTypeGetFlags(type_: MlirType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is signed, `false` otherwise."]
    pub fn mlirQuantizedTypeIsSigned(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the underlying type used to store the values."]
    pub fn mlirQuantizedTypeGetStorageType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns the minimum value that the storage type of the given quantized type\n can take."]
    pub fn mlirQuantizedTypeGetStorageTypeMin(type_: MlirType) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the maximum value that the storage type of the given quantized type\n can take."]
    pub fn mlirQuantizedTypeGetStorageTypeMax(type_: MlirType) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the integral bitwidth that the storage type of the given quantized\n type can represent exactly."]
    pub fn mlirQuantizedTypeGetStorageTypeIntegralWidth(type_: MlirType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the `candidate` type is compatible with the given\n quantized `type`."]
    pub fn mlirQuantizedTypeIsCompatibleExpressedType(type_: MlirType, candidate: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the element type of the given quantized type as another quantized\n type."]
    pub fn mlirQuantizedTypeGetQuantizedElementType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Casts from a type based on the storage type of the given type to a\n corresponding type based on the given type. Returns a null type if the cast\n is not valid."]
    pub fn mlirQuantizedTypeCastFromStorageType(type_: MlirType, candidate: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Casts from a type based on a quantized type to a corresponding typed based\n on the storage type. Returns a null type if the cast is not valid."]
    pub fn mlirQuantizedTypeCastToStorageType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Casts from a type based on the expressed type of the given type to a\n corresponding type based on the given type. Returns a null type if the cast\n is not valid."]
    pub fn mlirQuantizedTypeCastFromExpressedType(type_: MlirType, candidate: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Casts from a type based on a quantized type to a corresponding typed based\n on the expressed type. Returns a null type if the cast is not valid."]
    pub fn mlirQuantizedTypeCastToExpressedType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Casts from a type based on the expressed type of the given quantized type to\n equivalent type based on storage type of the same quantized type."]
    pub fn mlirQuantizedTypeCastExpressedToStorageType(type_: MlirType, candidate: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is an AnyQuantizedType."]
    pub fn mlirTypeIsAAnyQuantizedType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirAnyQuantizedTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates an instance of AnyQuantizedType with the given parameters in the\n same context as `storageType` and returns it. The instance is owned by the\n context."]
    pub fn mlirAnyQuantizedTypeGet(
        flags: ::std::os::raw::c_uint,
        storageType: MlirType,
        expressedType: MlirType,
        storageTypeMin: i64,
        storageTypeMax: i64,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirAnyQuantizedTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is a UniformQuantizedType."]
    pub fn mlirTypeIsAUniformQuantizedType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirUniformQuantizedTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates an instance of UniformQuantizedType with the given parameters in the\n same context as `storageType` and returns it. The instance is owned by the\n context."]
    pub fn mlirUniformQuantizedTypeGet(
        flags: ::std::os::raw::c_uint,
        storageType: MlirType,
        expressedType: MlirType,
        scale: f64,
        zeroPoint: i64,
        storageTypeMin: i64,
        storageTypeMax: i64,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirUniformQuantizedTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the scale of the given uniform quantized type."]
    pub fn mlirUniformQuantizedTypeGetScale(type_: MlirType) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the zero point of the given uniform quantized type."]
    pub fn mlirUniformQuantizedTypeGetZeroPoint(type_: MlirType) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given uniform quantized type is fixed-point."]
    pub fn mlirUniformQuantizedTypeIsFixedPoint(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is a UniformQuantizedPerAxisType."]
    pub fn mlirTypeIsAUniformQuantizedPerAxisType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirUniformQuantizedPerAxisTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates an instance of UniformQuantizedPerAxisType with the given parameters\n in the same context as `storageType` and returns it. `scales` and\n `zeroPoints` point to `nDims` number of elements. The instance is owned\n by the context."]
    pub fn mlirUniformQuantizedPerAxisTypeGet(
        flags: ::std::os::raw::c_uint,
        storageType: MlirType,
        expressedType: MlirType,
        nDims: isize,
        scales: *mut f64,
        zeroPoints: *mut i64,
        quantizedDimension: i32,
        storageTypeMin: i64,
        storageTypeMax: i64,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirUniformQuantizedPerAxisTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of axes in the given quantized per-axis type."]
    pub fn mlirUniformQuantizedPerAxisTypeGetNumDims(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th scale of the given quantized per-axis type."]
    pub fn mlirUniformQuantizedPerAxisTypeGetScale(type_: MlirType, pos: isize) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns `pos`-th zero point of the given quantized per-axis type."]
    pub fn mlirUniformQuantizedPerAxisTypeGetZeroPoint(type_: MlirType, pos: isize) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the index of the quantized dimension in the given quantized per-axis\n type."]
    pub fn mlirUniformQuantizedPerAxisTypeGetQuantizedDimension(type_: MlirType) -> i32;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given uniform quantized per-axis type is fixed-point."]
    pub fn mlirUniformQuantizedPerAxisTypeIsFixedPoint(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is a UniformQuantizedSubChannel."]
    pub fn mlirTypeIsAUniformQuantizedSubChannelType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirUniformQuantizedSubChannelTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates a UniformQuantizedSubChannelType with the given parameters.\n\n The type is owned by the context. `scalesAttr` and `zeroPointsAttr` must be\n DenseElementsAttrs.  `quantizedDimensions` and `blockSizes`\n point to `blockSizeInfoLength` number of elements, describing respectively\n the quantization axis and corresponding block size."]
    pub fn mlirUniformQuantizedSubChannelTypeGet(
        flags: ::std::os::raw::c_uint,
        storageType: MlirType,
        expressedType: MlirType,
        scalesAttr: MlirAttribute,
        zeroPointsAttr: MlirAttribute,
        blockSizeInfoLength: isize,
        quantizedDimensions: *mut i32,
        blockSizes: *mut i64,
        storageTypeMin: i64,
        storageTypeMax: i64,
    ) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirUniformQuantizedSubChannelTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the number of block sizes provided in type."]
    pub fn mlirUniformQuantizedSubChannelTypeGetNumBlockSizes(type_: MlirType) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns the quantized dimension at the given position."]
    pub fn mlirUniformQuantizedSubChannelTypeGetQuantizedDimension(type_: MlirType, pos: isize) -> i32;
}
unsafe extern "C" {
    #[doc = " Returns the block size at the given position."]
    pub fn mlirUniformQuantizedSubChannelTypeGetBlockSize(type_: MlirType, pos: isize) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the scales of the quantized type."]
    pub fn mlirUniformQuantizedSubChannelTypeGetScales(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the zero-points of the quantized type."]
    pub fn mlirUniformQuantizedSubChannelTypeGetZeroPoints(type_: MlirType) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns `true` if the given type is a CalibratedQuantizedType."]
    pub fn mlirTypeIsACalibratedQuantizedType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirCalibratedQuantizedTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    #[doc = " Creates an instance of CalibratedQuantizedType with the given parameters\n in the same context as `expressedType` and returns it. The instance is owned\n by the context."]
    pub fn mlirCalibratedQuantizedTypeGet(expressedType: MlirType, min: f64, max: f64) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirCalibratedQuantizedTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the min value of the given calibrated quantized type."]
    pub fn mlirCalibratedQuantizedTypeGetMin(type_: MlirType) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the max value of the given calibrated quantized type."]
    pub fn mlirCalibratedQuantizedTypeGetMax(type_: MlirType) -> f64;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__rocdl__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__scf__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateSCFForLoopCanonicalization() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForLoopCanonicalization();
}
unsafe extern "C" {
    pub fn mlirCreateSCFForLoopPeeling() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForLoopPeeling();
}
unsafe extern "C" {
    pub fn mlirCreateSCFForLoopRangeFolding() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForLoopRangeFolding();
}
unsafe extern "C" {
    pub fn mlirCreateSCFForLoopSpecialization() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForLoopSpecialization();
}
unsafe extern "C" {
    pub fn mlirCreateSCFForToWhileLoop() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForToWhileLoop();
}
unsafe extern "C" {
    pub fn mlirCreateSCFForallToForLoop() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForallToForLoop();
}
unsafe extern "C" {
    pub fn mlirCreateSCFForallToParallelLoop() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFForallToParallelLoop();
}
unsafe extern "C" {
    pub fn mlirCreateSCFParallelForToNestedFors() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFParallelForToNestedFors();
}
unsafe extern "C" {
    pub fn mlirCreateSCFParallelLoopFusion() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFParallelLoopFusion();
}
unsafe extern "C" {
    pub fn mlirCreateSCFParallelLoopSpecialization() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFParallelLoopSpecialization();
}
unsafe extern "C" {
    pub fn mlirCreateSCFParallelLoopTiling() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSCFParallelLoopTiling();
}
unsafe extern "C" {
    pub fn mlirCreateTestSCFParallelLoopCollapsing() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterTestSCFParallelLoopCollapsing();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__shape__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateOutlineShapeComputationPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterOutlineShapeComputationPass();
}
unsafe extern "C" {
    pub fn mlirCreateRemoveShapeConstraintsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterRemoveShapeConstraintsPass();
}
unsafe extern "C" {
    pub fn mlirCreateShapeToShapeLoweringPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterShapeToShapeLoweringPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__smt__() -> MlirDialectHandle;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is any non-func SMT value type."]
    pub fn mlirSMTTypeIsAnyNonFuncSMTValueType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is any SMT value type."]
    pub fn mlirSMTTypeIsAnySMTValueType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is a smt::ArrayType."]
    pub fn mlirSMTTypeIsAArray(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates an array type with the given domain and range types."]
    pub fn mlirSMTTypeGetArray(ctx: MlirContext, domainType: MlirType, rangeType: MlirType) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is a smt::BitVectorType."]
    pub fn mlirSMTTypeIsABitVector(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a smt::BitVectorType with the given width."]
    pub fn mlirSMTTypeGetBitVector(ctx: MlirContext, width: i32) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirSMTBitVectorTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is a smt::BoolType."]
    pub fn mlirSMTTypeIsABool(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a smt::BoolType."]
    pub fn mlirSMTTypeGetBool(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirSMTBoolTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is a smt::IntType."]
    pub fn mlirSMTTypeIsAInt(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a smt::IntType."]
    pub fn mlirSMTTypeGetInt(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirSMTIntTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is a smt::FuncType."]
    pub fn mlirSMTTypeIsASMTFunc(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a smt::FuncType with the given domain and range types."]
    pub fn mlirSMTTypeGetSMTFunc(
        ctx: MlirContext,
        numberOfDomainTypes: usize,
        domainTypes: *const MlirType,
        rangeType: MlirType,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Checks if the given type is a smt::SortType."]
    pub fn mlirSMTTypeIsASort(type_: MlirType) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a smt::SortType with the given identifier and sort parameters."]
    pub fn mlirSMTTypeGetSort(
        ctx: MlirContext,
        identifier: MlirIdentifier,
        numberOfSortParams: usize,
        sortParams: *const MlirType,
    ) -> MlirType;
}
unsafe extern "C" {
    #[doc = " Checks if the given string is a valid smt::BVCmpPredicate."]
    pub fn mlirSMTAttrCheckBVCmpPredicate(ctx: MlirContext, str_: MlirStringRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if the given string is a valid smt::IntPredicate."]
    pub fn mlirSMTAttrCheckIntPredicate(ctx: MlirContext, str_: MlirStringRef) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if the given attribute is a smt::SMTAttribute."]
    pub fn mlirSMTAttrIsASMTAttribute(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a smt::BitVectorAttr with the given value and width."]
    pub fn mlirSMTAttrGetBitVector(ctx: MlirContext, value: u64, width: ::std::os::raw::c_uint) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a smt::BVCmpPredicateAttr with the given string."]
    pub fn mlirSMTAttrGetBVCmpPredicate(ctx: MlirContext, str_: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Creates a smt::IntPredicateAttr with the given string."]
    pub fn mlirSMTAttrGetIntPredicate(ctx: MlirContext, str_: MlirStringRef) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__sparse_tensor__() -> MlirDialectHandle;
}
#[doc = " Dimension level types (and properties) that define sparse tensors.\n See the documentation in SparseTensorAttrDefs.td for their meaning.\n\n These correspond to SparseTensorEncodingAttr::LevelType in the C++ API.\n If updating, keep them in sync and update the static_assert in the impl\n file."]
pub type MlirSparseTensorLevelType = u64;
pub const MlirSparseTensorLevelFormat_MLIR_SPARSE_TENSOR_LEVEL_DENSE: MlirSparseTensorLevelFormat = 65536;
pub const MlirSparseTensorLevelFormat_MLIR_SPARSE_TENSOR_LEVEL_BATCH: MlirSparseTensorLevelFormat = 131072;
pub const MlirSparseTensorLevelFormat_MLIR_SPARSE_TENSOR_LEVEL_COMPRESSED: MlirSparseTensorLevelFormat = 262144;
pub const MlirSparseTensorLevelFormat_MLIR_SPARSE_TENSOR_LEVEL_SINGLETON: MlirSparseTensorLevelFormat = 524288;
pub const MlirSparseTensorLevelFormat_MLIR_SPARSE_TENSOR_LEVEL_LOOSE_COMPRESSED: MlirSparseTensorLevelFormat = 1048576;
pub const MlirSparseTensorLevelFormat_MLIR_SPARSE_TENSOR_LEVEL_N_OUT_OF_M: MlirSparseTensorLevelFormat = 2097152;
pub type MlirSparseTensorLevelFormat = ::std::os::raw::c_uint;
pub const MlirSparseTensorLevelPropertyNondefault_MLIR_SPARSE_PROPERTY_NON_UNIQUE:
    MlirSparseTensorLevelPropertyNondefault = 1;
pub const MlirSparseTensorLevelPropertyNondefault_MLIR_SPARSE_PROPERTY_NON_ORDERED:
    MlirSparseTensorLevelPropertyNondefault = 2;
pub const MlirSparseTensorLevelPropertyNondefault_MLIR_SPARSE_PROPERTY_SOA: MlirSparseTensorLevelPropertyNondefault = 4;
pub type MlirSparseTensorLevelPropertyNondefault = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Checks whether the given attribute is a `sparse_tensor.encoding` attribute."]
    pub fn mlirAttributeIsASparseTensorEncodingAttr(attr: MlirAttribute) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a `sparse_tensor.encoding` attribute with the given parameters."]
    pub fn mlirSparseTensorEncodingAttrGet(
        ctx: MlirContext,
        lvlRank: isize,
        lvlTypes: *const MlirSparseTensorLevelType,
        dimToLvl: MlirAffineMap,
        lvlTodim: MlirAffineMap,
        posWidth: ::std::os::raw::c_int,
        crdWidth: ::std::os::raw::c_int,
        explicitVal: MlirAttribute,
        implicitVal: MlirAttribute,
    ) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirSparseTensorEncodingAttrGetName() -> MlirStringRef;
}
unsafe extern "C" {
    #[doc = " Returns the level-rank of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingGetLvlRank(attr: MlirAttribute) -> isize;
}
unsafe extern "C" {
    #[doc = " Returns a specified level-type of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingAttrGetLvlType(attr: MlirAttribute, lvl: isize) -> MlirSparseTensorLevelType;
}
unsafe extern "C" {
    #[doc = " Returns a specified level-format of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingAttrGetLvlFmt(attr: MlirAttribute, lvl: isize) -> MlirSparseTensorLevelFormat;
}
unsafe extern "C" {
    #[doc = " Returns the dimension-to-level mapping of the `sparse_tensor.encoding`\n attribute."]
    pub fn mlirSparseTensorEncodingAttrGetDimToLvl(attr: MlirAttribute) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the level-to-dimension mapping of the `sparse_tensor.encoding`\n attribute."]
    pub fn mlirSparseTensorEncodingAttrGetLvlToDim(attr: MlirAttribute) -> MlirAffineMap;
}
unsafe extern "C" {
    #[doc = " Returns the position bitwidth of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingAttrGetPosWidth(attr: MlirAttribute) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the coordinate bitwidth of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingAttrGetCrdWidth(attr: MlirAttribute) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the explicit value of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingAttrGetExplicitVal(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    #[doc = " Returns the implicit value of the `sparse_tensor.encoding` attribute."]
    pub fn mlirSparseTensorEncodingAttrGetImplicitVal(attr: MlirAttribute) -> MlirAttribute;
}
unsafe extern "C" {
    pub fn mlirSparseTensorEncodingAttrGetStructuredN(lvlType: MlirSparseTensorLevelType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn mlirSparseTensorEncodingAttrGetStructuredM(lvlType: MlirSparseTensorLevelType) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn mlirSparseTensorEncodingAttrBuildLvlType(
        lvlFmt: MlirSparseTensorLevelFormat,
        properties: *const MlirSparseTensorLevelPropertyNondefault,
        propSize: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
        m: ::std::os::raw::c_uint,
    ) -> MlirSparseTensorLevelType;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorPasses();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorLowerForeachToSCF() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorLowerForeachToSCF();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorLowerSparseIterationToSCF() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorLowerSparseIterationToSCF();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorLowerSparseOpsToForeach() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorLowerSparseOpsToForeach();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorPreSparsificationRewrite() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorPreSparsificationRewrite();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseAssembler() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseAssembler();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseBufferRewrite() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseBufferRewrite();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseGPUCodegen() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseGPUCodegen();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseReinterpretMap() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseReinterpretMap();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseSpaceCollapse() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseSpaceCollapse();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseTensorCodegen() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseTensorCodegen();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseTensorConversionPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseTensorConversionPass();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparseVectorization() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparseVectorization();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparsificationAndBufferization() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparsificationAndBufferization();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorSparsificationPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorSparsificationPass();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorStageSparseOperations() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorStageSparseOperations();
}
unsafe extern "C" {
    pub fn mlirCreateSparseTensorStorageSpecifierToLLVM() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterSparseTensorStorageSpecifierToLLVM();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__tensor__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateFoldTensorSubsetOpsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterFoldTensorSubsetOpsPass();
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__transform__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirTypeIsATransformAnyOpType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirTransformAnyOpTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirTransformAnyOpTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTransformAnyOpTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsATransformAnyParamType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirTransformAnyParamTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirTransformAnyParamTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTransformAnyParamTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsATransformAnyValueType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirTransformAnyValueTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirTransformAnyValueTypeGet(ctx: MlirContext) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTransformAnyValueTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsATransformOperationType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirTransformOperationTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirTransformOperationTypeGet(ctx: MlirContext, operationName: MlirStringRef) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTransformOperationTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTransformOperationTypeGetOperationName(type_: MlirType) -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTypeIsATransformParamType(type_: MlirType) -> bool;
}
unsafe extern "C" {
    pub fn mlirTransformParamTypeGetTypeID() -> MlirTypeID;
}
unsafe extern "C" {
    pub fn mlirTransformParamTypeGet(ctx: MlirContext, type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirTransformParamTypeGetName() -> MlirStringRef;
}
unsafe extern "C" {
    pub fn mlirTransformParamTypeGetType(type_: MlirType) -> MlirType;
}
unsafe extern "C" {
    pub fn mlirCreateCheckUsesPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterCheckUsesPass();
}
unsafe extern "C" {
    pub fn mlirCreateInferEffectsPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterInferEffectsPass();
}
unsafe extern "C" {
    pub fn mlirCreateInterpreterPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterInterpreterPass();
}
unsafe extern "C" {
    pub fn mlirCreatePreloadLibraryPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterPreloadLibraryPass();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTransformOptions {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirTransformOptions"][::std::mem::size_of::<MlirTransformOptions>() - 8usize];
    ["Alignment of MlirTransformOptions"][::std::mem::align_of::<MlirTransformOptions>() - 8usize];
    ["Offset of field: MlirTransformOptions::ptr"][::std::mem::offset_of!(MlirTransformOptions, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Creates a default-initialized transform options object."]
    pub fn mlirTransformOptionsCreate() -> MlirTransformOptions;
}
unsafe extern "C" {
    #[doc = " Enables or disables expensive checks in transform options."]
    pub fn mlirTransformOptionsEnableExpensiveChecks(transformOptions: MlirTransformOptions, enable: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if expensive checks are enabled in transform options."]
    pub fn mlirTransformOptionsGetExpensiveChecksEnabled(transformOptions: MlirTransformOptions) -> bool;
}
unsafe extern "C" {
    #[doc = " Enables or disables the enforcement of the top-level transform op being\n single in transform options."]
    pub fn mlirTransformOptionsEnforceSingleTopLevelTransformOp(transformOptions: MlirTransformOptions, enable: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if the enforcement of the top-level transform op being single\n is enabled in transform options."]
    pub fn mlirTransformOptionsGetEnforceSingleTopLevelTransformOp(transformOptions: MlirTransformOptions) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroys a transform options object previously created by\n mlirTransformOptionsCreate."]
    pub fn mlirTransformOptionsDestroy(transformOptions: MlirTransformOptions);
}
unsafe extern "C" {
    #[doc = " Applies the transformation script starting at the given transform root\n operation to the given payload operation. The module containing the\n transform root as well as the transform options should be provided. The\n transform operation must implement TransformOpInterface and the module must\n be a ModuleOp. Returns the status of the application."]
    pub fn mlirTransformApplyNamedSequence(
        payload: MlirOperation,
        transformRoot: MlirOperation,
        transformModule: MlirOperation,
        transformOptions: MlirTransformOptions,
    ) -> MlirLogicalResult;
}
unsafe extern "C" {
    #[doc = " Merge the symbols from `other` into `target`, potentially renaming them to\n avoid conflicts. Private symbols may be renamed during the merge, public\n symbols must have at most one declaration. A name conflict in public symbols\n is reported as an error before returning a failure.\n\n Note that this clones the `other` operation unlike the C++ counterpart that\n takes ownership."]
    pub fn mlirMergeSymbolsIntoFromClone(target: MlirOperation, other: MlirOperation) -> MlirLogicalResult;
}
unsafe extern "C" {
    pub fn mlirGetDialectHandle__vector__() -> MlirDialectHandle;
}
unsafe extern "C" {
    pub fn mlirCreateLowerVectorMaskPass() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLowerVectorMaskPass();
}
unsafe extern "C" {
    pub fn mlirCreateLowerVectorMultiReduction() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLowerVectorMultiReduction();
}
unsafe extern "C" {
    pub fn mlirCreateLowerVectorToFromElementsToShuffleTree() -> MlirPass;
}
unsafe extern "C" {
    pub fn mlirRegisterLowerVectorToFromElementsToShuffleTree();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueContext {
    _unused: [u8; 0],
}
#[doc = " The top-level container for all LLVM global data. See the LLVMContext class."]
pub type LLVMContextRef = *mut LLVMOpaqueContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModule {
    _unused: [u8; 0],
}
#[doc = " The top-level container for all other LLVM Intermediate Representation (IR)\n objects.\n\n @see llvm::Module"]
pub type LLVMModuleRef = *mut LLVMOpaqueModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueType {
    _unused: [u8; 0],
}
#[doc = " Each value in the LLVM IR has a type, an LLVMTypeRef.\n\n @see llvm::Type"]
pub type LLVMTypeRef = *mut LLVMOpaqueType;
unsafe extern "C" {
    #[doc = " Translate operation that satisfies LLVM dialect module requirements into an\n LLVM IR module living in the given context. This translates operations from\n any dilalect that has a registered implementation of\n LLVMTranslationDialectInterface.\n\n \\returns the generated LLVM IR Module from the translated MLIR module, it is\n owned by the caller."]
    pub fn mlirTranslateModuleToLLVMIR(module: MlirOperation, context: LLVMContextRef) -> LLVMModuleRef;
}
unsafe extern "C" {
    pub fn mlirTranslateModuleToLLVMIRToString(module: MlirOperation) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTypeFromLLVMIRTranslator {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirTypeFromLLVMIRTranslator"][::std::mem::size_of::<MlirTypeFromLLVMIRTranslator>() - 8usize];
    ["Alignment of MlirTypeFromLLVMIRTranslator"][::std::mem::align_of::<MlirTypeFromLLVMIRTranslator>() - 8usize];
    ["Offset of field: MlirTypeFromLLVMIRTranslator::ptr"]
        [::std::mem::offset_of!(MlirTypeFromLLVMIRTranslator, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Create an LLVM::TypeFromLLVMIRTranslator and transfer ownership to the\n caller."]
    pub fn mlirTypeFromLLVMIRTranslatorCreate(ctx: MlirContext) -> MlirTypeFromLLVMIRTranslator;
}
unsafe extern "C" {
    #[doc = " Takes an LLVM::TypeFromLLVMIRTranslator owned by the caller and destroys it.\n It is the responsibility of the user to only pass an\n LLVM::TypeFromLLVMIRTranslator class."]
    pub fn mlirTypeFromLLVMIRTranslatorDestroy(translator: MlirTypeFromLLVMIRTranslator);
}
unsafe extern "C" {
    #[doc = " Translates the given LLVM IR type to the MLIR LLVM dialect."]
    pub fn mlirTypeFromLLVMIRTranslatorTranslateType(
        translator: MlirTypeFromLLVMIRTranslator,
        llvmType: LLVMTypeRef,
    ) -> MlirType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTypeToLLVMIRTranslator {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MlirTypeToLLVMIRTranslator"][::std::mem::size_of::<MlirTypeToLLVMIRTranslator>() - 8usize];
    ["Alignment of MlirTypeToLLVMIRTranslator"][::std::mem::align_of::<MlirTypeToLLVMIRTranslator>() - 8usize];
    ["Offset of field: MlirTypeToLLVMIRTranslator::ptr"]
        [::std::mem::offset_of!(MlirTypeToLLVMIRTranslator, ptr) - 0usize];
};
unsafe extern "C" {
    #[doc = " Create an LLVM::TypeToLLVMIRTranslator and transfer ownership to the\n caller."]
    pub fn mlirTypeToLLVMIRTranslatorCreate(ctx: LLVMContextRef) -> MlirTypeToLLVMIRTranslator;
}
unsafe extern "C" {
    #[doc = " Takes an LLVM::TypeToLLVMIRTranslator owned by the caller and destroys it.\n It is the responsibility of the user to only pass an\n LLVM::TypeToLLVMIRTranslator class."]
    pub fn mlirTypeToLLVMIRTranslatorDestroy(translator: MlirTypeToLLVMIRTranslator);
}
unsafe extern "C" {
    #[doc = " Translates the given MLIR LLVM dialect to the LLVM IR type."]
    pub fn mlirTypeToLLVMIRTranslatorTranslateType(
        translator: MlirTypeToLLVMIRTranslator,
        mlirType: MlirType,
    ) -> LLVMTypeRef;
}
